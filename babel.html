<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Fall of Babel: Architect Mode VII (Typist)</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <style>
        :root {
            --bg: #050505;
            --text: #cccccc;
            --accent: #eebb99; /* Hebrew Gold */
            --panel-bg: rgba(10, 10, 10, 0.90);
            --border: #333;
            --danger: #ff5555;
            --active-tab: #222;
        }
        body {
            margin: 0; padding: 0; overflow: hidden;
            background-color: var(--bg);
            color: var(--text);
            font-family: 'Courier New', Courier, monospace;
            user-select: none;
        }
        canvas { display: block; position: relative; z-index: 1; }
        
        /* Cursor styling */
        body.mode-drag canvas { cursor: grab; }
        body.mode-drag canvas:active { cursor: grabbing; }
        body.mode-shatter canvas { cursor: crosshair; }
        
        body.mode-draw.tool-free canvas { cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2"><path d="M12 19l7-7 3 3-7 7-3-3z"/><path d="M18 13l-1.5-7.5L2 2l3.5 14.5L13 18l5-5z"/><path d="M2 2l7.586 7.586"/><circle cx="11" cy="11" r="2"/></svg>') 0 24, auto; }
        body.mode-draw.tool-line canvas { cursor: crosshair; }
        body.mode-draw.tool-erase canvas { cursor: cell; }

        /* --- UI LAYER --- */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 10;
        }

        /* Background Reference Layer */
        #bg-reference {
            position: absolute; top:0; left:0; width:100%; height:100%;
            background-size: contain; background-repeat: no-repeat; background-position: center;
            opacity: 0.3; pointer-events: none; z-index: 0;
        }

        #settings-trigger {
            position: absolute; top: 20px; right: 20px;
            font-size: 24px; cursor: pointer; pointer-events: auto;
            color: #444; transition: color 0.3s, transform 0.5s;
            z-index: 100;
        }
        #settings-trigger:hover { color: var(--text); transform: rotate(90deg); }

        /* --- NEW CONTROL PANEL LAYOUT --- */
        #control-panel {
            position: absolute; top: 0; right: 0;
            width: 360px; height: 100%;
            background: var(--panel-bg);
            border-left: 1px solid var(--border);
            backdrop-filter: blur(10px);
            transform: translateX(100%);
            transition: transform 0.4s cubic-bezier(0.16, 1, 0.3, 1);
            pointer-events: auto;
            display: flex; flex-direction: column;
        }
        #control-panel.active { transform: translateX(0); }

        /* Fixed Header Area */
        .panel-header {
            padding: 20px 20px 10px 20px;
            border-bottom: 1px solid var(--border);
            flex-shrink: 0;
        }

        /* Tabs Navigation */
        .tabs-nav {
            display: flex;
            background: #000;
            border-bottom: 1px solid var(--border);
        }
        .tabs-nav button {
            flex: 1; border: none; background: transparent;
            padding: 12px 0; font-size: 11px; color: #666;
            cursor: pointer; border-bottom: 2px solid transparent;
            transition: all 0.2s;
        }
        .tabs-nav button:hover { color: #aaa; background: #111; }
        .tabs-nav button.active { 
            color: var(--accent); border-bottom: 2px solid var(--accent); background: #0a0a0a; 
        }

        /* Scrollable Content Area */
        .panel-content {
            flex: 1; overflow-y: auto; padding: 20px;
            position: relative;
        }

        /* Tab Contents */
        .tab-section { display: none; flex-direction: column; gap: 25px; animation: fadeIn 0.3s ease; }
        .tab-section.active { display: flex; }

        @keyframes fadeIn { from { opacity: 0; transform: translateY(5px); } to { opacity: 1; transform: translateY(0); } }

        /* Standard Controls */
        h2 { 
            font-size: 10px; border-bottom: 1px solid var(--border); 
            padding-bottom: 5px; margin: 0 0 10px 0; color: #666; letter-spacing: 2px; 
        }
        
        .control-group { display: flex; flex-direction: column; gap: 8px; margin-bottom: 5px; }
        .label-row { display: flex; justify-content: space-between; font-size: 10px; color: #888; }
        
        input[type="range"] { -webkit-appearance: none; width: 100%; background: transparent; }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none; height: 12px; width: 4px;
            background: var(--accent); cursor: ew-resize; margin-top: -5px;
            box-shadow: 0 0 10px rgba(238, 187, 153, 0.5);
        }
        input[type="range"]::-webkit-slider-runnable-track { width: 100%; height: 2px; background: #333; }

        textarea {
            background: #080808; border: 1px solid var(--border);
            color: var(--text); width: 100%; height: 60px;
            font-family: inherit; font-size: 10px; padding: 10px;
            resize: vertical; outline: none;
        }
        
        button {
            background: transparent; border: 1px solid var(--border);
            color: var(--text); padding: 10px; font-family: inherit;
            cursor: pointer; font-size: 10px; transition: all 0.2s;
            letter-spacing: 1px;
        }
        button:hover { background: #222; border-color: var(--text); }
        button.active { border-color: var(--accent); color: var(--accent); background: rgba(238, 187, 153, 0.1); }
        
        .mode-toggle-group { display: flex; gap: 5px; }
        .mode-toggle-group button { flex: 1; font-size: 9px; padding: 10px 5px; }

        /* Color Picker Buttons */
        #line-color-picker button { flex:1; height:20px; border:1px solid #333; }
        #line-color-picker button:hover { opacity: 0.8; }
        #line-color-picker button.active { border:2px solid #fff; transform:scale(1.1); box-shadow: 0 0 10px rgba(255,255,255,0.2); }

        #architect-controls { display: none; margin-top: 10px; padding-top: 10px; border-top: 1px dashed #333; }
        .mode-draw #architect-controls { display: flex; }

        #audio-status {
            position: absolute; bottom: 20px; left: 20px;
            font-size: 10px; color: var(--accent); letter-spacing: 1px;
            opacity: 0; transition: opacity 1s;
        }

        #tooltip {
            position: absolute; top: 20px; left: 20px;
            font-size: 11px; color: #666;
            pointer-events: none;
            display: none;
            z-index: 20;
        }
        .mode-draw #tooltip { display: block; }

        /* Typing Buffer Visual */
        #typing-buffer-display {
            position: absolute; top: 50px; left: 20px;
            font-size: 14px; color: var(--accent);
            opacity: 0.7; pointer-events: none;
        }

        .vignette {
            position: absolute; top:0; left:0; width:100%; height:100%;
            background: radial-gradient(circle, transparent 40%, black 140%);
            pointer-events: none;
            z-index: 5;
        }
        .grain {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            opacity: 0.05; pointer-events: none;
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.85' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)'/%3E%3C/svg%3E");
            animation: grain 1s steps(10) infinite;
            z-index: 5;
        }
        @keyframes grain { 0%, 100% {transform:translate(0,0)} 20% {transform:translate(-2px,2px)} 40% {transform:translate(2px,-2px)} 60% {transform:translate(-2px,-2px)} 80% {transform:translate(2px,2px)} }
    </style>
</head>
<body class="mode-shatter">

    <div id="ui-layer">
        <div id="bg-reference"></div>
        <div class="grain"></div>
        <div class="vignette"></div>
        <div id="audio-status">AUDIO ENGINE :: ONLINE</div>
        <div id="tooltip">[SHIFT] Snap Axis • [CTRL+Z] Undo</div>
        <div id="typing-buffer-display"></div>
        <div id="settings-trigger">[ ☼ ]</div>
        
        <div id="control-panel">
            
            <div class="panel-header">
                <h2>CURSOR MODE</h2>
                <div class="control-group mode-toggle-group">
                    <button id="btn-mode-drag">MANIPULATE</button>
                    <button id="btn-mode-shatter" class="active">DISRUPT</button>
                    <button id="btn-mode-draw">ARCHITECT</button>
                </div>
                <div id="architect-controls" class="control-group">
                    <div class="label-row" style="margin-bottom:5px;"><span>TOOL</span></div>
                    <div class="mode-toggle-group">
                        <button id="btn-tool-free" class="active">FREE</button>
                        <button id="btn-tool-line">LINE</button>
                        <button id="btn-tool-erase">ERASE</button>
                    </div>
                </div>
            </div>

            <div class="tabs-nav">
                <button class="tab-btn active" data-target="tab-sim">SIM</button>
                <button class="tab-btn" data-target="tab-arch">ARCH</button>
                <button class="tab-btn" data-target="tab-vis">VIS</button>
                <button class="tab-btn" data-target="tab-data">DATA</button>
            </div>

            <div class="panel-content">
                
                <div id="tab-sim" class="tab-section active">
                    <h2>SPAWN MODE</h2>
                    <div class="control-group mode-toggle-group">
                        <button id="btn-spawn-auto" class="active">AUTO DROP</button>
                        <button id="btn-spawn-type">TYPE INPUT</button>
                    </div>
                    
                    <div id="typing-settings" class="control-group" style="display:none; margin-top:5px; border-top:1px dashed #333; padding-top:10px;">
                        <div class="label-row" style="margin-bottom:5px;"><span>INPUT METHOD</span></div>
                        <div class="mode-toggle-group">
                            <button id="btn-type-char" class="active">1 KEY = 1 CHAR</button>
                            <button id="btn-type-enter">DROP ON ENTER</button>
                        </div>
                        <div style="font-size:9px; color:#666; margin-top:5px;">
                            <span id="type-desc">Press any key to drop a character.</span>
                        </div>
                    </div>

                    <h2>INTERACTION TRIGGER</h2>
                    <div class="control-group mode-toggle-group">
                        <button id="btn-trigger-click" class="active">CLICK</button>
                        <button id="btn-trigger-hover">HOVER</button>
                    </div>

                    <h2>PHYSICS</h2>
                    <div class="control-group">
                        <div class="label-row"><span>GRAVITY</span><span id="val-gravity">1.0</span></div>
                        <input type="range" id="inp-gravity" min="0" max="2" step="0.1" value="1">
                    </div>
                    <div class="control-group">
                        <div class="label-row"><span>FORCE</span><span id="val-force">0.12</span></div>
                        <input type="range" id="inp-force" min="0.01" max="0.5" step="0.01" value="0.12">
                    </div>

                    <h2>FLOW (AUTO MODE)</h2>
                    <div class="control-group">
                        <div class="label-row"><span>DELAY</span><span id="val-speed">35</span></div>
                        <input type="range" id="inp-speed" min="5" max="100" step="1" value="35">
                    </div>
                    <div class="control-group" style="flex-direction:row; justify-content:space-between; align-items:center;">
                        <span style="font-size:10px; color:#888;">INFINITE LOOP</span>
                        <input type="checkbox" id="inp-loop" checked style="width:auto; margin:0;">
                    </div>

                    <h2>MAINTENANCE</h2>
                    <button id="btn-sweep" style="color:#eebb99; border-color:#664422;">SWEEP DEBRIS</button>
                    <button id="btn-clear" style="color:#ff6666; border-color:#663333;">PURGE ALL</button>
                </div>

                <div id="tab-arch" class="tab-section">
                    <h2>BLUEPRINT</h2>
                    <div class="control-group" style="display:flex; flex-direction:row; gap:5px;">
                        <button id="btn-save" style="flex:1;">SAVE LAYOUT</button>
                        <button id="btn-load" style="flex:1;">LOAD LAYOUT</button>
                    </div>

                    <h2>LINE PROPERTIES</h2>
                    <div class="control-group">
                        <div class="label-row"><span>FRICTION</span><span id="val-friction">0.1</span></div>
                        <input type="range" id="inp-friction" min="0" max="1" step="0.05" value="0.1">
                    </div>
                    <div class="control-group">
                        <div class="label-row"><span>THICKNESS</span><span id="val-thickness">4</span></div>
                        <input type="range" id="inp-thickness" min="2" max="40" step="1" value="4">
                    </div>
                </div>

                <div id="tab-vis" class="tab-section">
                    <h2>TYPOGRAPHY</h2>
                    <div class="control-group">
                        <div class="label-row"><span>TEXT SIZE (RESETS)</span><span id="val-fontsize">22</span></div>
                        <input type="range" id="inp-fontsize" min="10" max="60" step="2" value="22">
                    </div>

                    <h2>PALETTE</h2>
                    <div class="control-group">
                        <div class="label-row"><span>LINE COLOR</span></div>
                        <div class="mode-toggle-group" id="line-color-picker">
                            <button data-col="#ffffff" style="background:#fff;" class="active"></button>
                            <button data-col="#eebb99" style="background:#eebb99;"></button>
                            <button data-col="#ff5555" style="background:#ff5555;"></button>
                            <button data-col="#5555ff" style="background:#5555ff;"></button>
                        </div>
                    </div>

                    <h2>REFERENCE</h2>
                    <div class="control-group">
                        <div class="label-row"><span>IMAGE URL</span></div>
                        <textarea id="inp-bg-url" placeholder="Paste image URL..." style="height:30px;"></textarea>
                        <div class="mode-toggle-group">
                            <button id="btn-load-bg">LOAD</button>
                            <button id="btn-clear-bg">CLEAR</button>
                        </div>
                    </div>
                </div>

                <div id="tab-data" class="tab-section">
                    <h2>AUDIO</h2>
                    <div class="control-group">
                        <button id="btn-audio-toggle">INITIALIZE AUDIO</button>
                    </div>
                    <div class="control-group">
                        <div class="label-row"><span>VOLUME</span><span id="val-vol">0.5</span></div>
                        <input type="range" id="inp-vol" min="0" max="1" step="0.05" value="0.5">
                    </div>

                    <h2>SOURCE TEXT</h2>
                    <div class="control-group">
                        <textarea id="inp-text" placeholder="Paste custom text..."></textarea>
                        <button id="btn-update-text">INJECT NEW STREAM</button>
                    </div>
                </div>

            </div>
        </div>
    </div>

    <script>
        // --- TAB SYSTEM LOGIC ---
        const tabBtns = document.querySelectorAll('.tab-btn');
        const tabSections = document.querySelectorAll('.tab-section');

        tabBtns.forEach(btn => {
            btn.addEventListener('click', () => {
                tabBtns.forEach(b => b.classList.remove('active'));
                tabSections.forEach(s => s.classList.remove('active'));
                btn.classList.add('active');
                const target = document.getElementById(btn.dataset.target);
                if(target) target.classList.add('active');
            });
        });

        // --- AUDIO ENGINE ---
        const AudioEngine = {
            ctx: null, masterGain: null, initialized: false,
            init: function() {
                if (this.initialized) return;
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                this.ctx = new AudioContext();
                const compressor = this.ctx.createDynamicsCompressor();
                compressor.threshold.setValueAtTime(-24, this.ctx.currentTime);
                compressor.knee.setValueAtTime(30, this.ctx.currentTime);
                compressor.ratio.setValueAtTime(12, this.ctx.currentTime);
                compressor.attack.setValueAtTime(0.003, this.ctx.currentTime);
                compressor.release.setValueAtTime(0.25, this.ctx.currentTime);
                this.masterGain = this.ctx.createGain();
                this.masterGain.gain.value = 0.5;
                this.masterGain.connect(compressor);
                compressor.connect(this.ctx.destination);
                this.initialized = true;
                this.startDrone();
                this.updateUI(true);
                const status = document.getElementById('audio-status');
                status.style.opacity = 0.6;
                setTimeout(() => status.style.opacity = 0, 4000);
            },
            toggle: function() {
                if (!this.initialized) { this.init(); return; }
                if (this.ctx.state === 'running') { this.ctx.suspend(); this.updateUI(false); } 
                else if (this.ctx.state === 'suspended') { this.ctx.resume(); this.updateUI(true); }
            },
            updateUI: function(active) {
                const btn = document.getElementById('btn-audio-toggle');
                if (active) { btn.innerText = "AUDIO :: ACTIVE"; btn.classList.add('active'); } 
                else { btn.innerText = "AUDIO :: SUSPENDED"; btn.classList.remove('active'); }
            },
            setVolume: function(val) { if(this.masterGain) this.masterGain.gain.setValueAtTime(val, this.ctx.currentTime); },
            startDrone: function() {
                [55, 65, 110, 220].forEach((f, i) => {
                    const osc = this.ctx.createOscillator();
                    const gain = this.ctx.createGain();
                    osc.type = i === 1 ? 'sine' : 'triangle'; 
                    osc.frequency.value = f;
                    const lfo = this.ctx.createOscillator();
                    lfo.frequency.value = 0.05 + Math.random() * 0.05;
                    const lfoGain = this.ctx.createGain();
                    lfoGain.gain.value = 0.01;
                    lfo.connect(lfoGain); lfoGain.connect(gain.gain);
                    gain.gain.value = 0.04; 
                    osc.connect(gain); gain.connect(this.masterGain); 
                    osc.start(); lfo.start();
                });
            },
            triggerBreak: function(panX) {
                if (!this.initialized || this.ctx.state === 'suspended') return;
                const t = this.ctx.currentTime;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                const panner = this.ctx.createStereoPanner();
                osc.frequency.setValueAtTime(400 + Math.random()*1000, t);
                osc.frequency.exponentialRampToValueAtTime(10, t + 0.15);
                gain.gain.setValueAtTime(0.3 * SETTINGS.force, t); 
                gain.gain.exponentialRampToValueAtTime(0.001, t + 0.15);
                panner.pan.value = panX;
                osc.connect(gain); gain.connect(panner); panner.connect(this.masterGain);
                osc.start(); osc.stop(t + 0.2);
            }
        };

        // --- GLOBAL SETTINGS ---
        const SETTINGS = {
            gravity: 1.0,
            force: 0.05,
            spawnInterval: 35,
            loop: true,
            interactionMode: 'shatter', 
            architectTool: 'freehand', 
            triggerMode: 'hover', // 'click' or 'hover'
            spawnMode: 'auto', // 'auto' or 'typing'
            typingType: 'char', // 'char' or 'enter'
            textSource: [],
            lineFriction: 0.1,
            lineThickness: 4
        };

        let typingBuffer = "";

        const DEFAULTS = [
            "Now the whole earth had one language and the same words.",
            "And as people migrated from the east, they found a plain in the land of Shinar and settled there.",
            "And they said to one another, Come, let us make bricks, and burn them thoroughly.",
            "Then they said, Come, let us build ourselves a city and a tower with its top in the heavens.",
            "And the Lord came down to see the city and the tower, which the children of man had built.",
            "And the Lord said, Behold, they are one people, and they have all one language.",
            "Come, let us go down and there confuse their language.",
            "So the Lord dispersed them from there over the face of all the earth.",
            "Therefore its name was called Babel, because there the Lord confused the language of all the earth.",
            "וַיְהִי כָל-הָאָרֶץ שָׂפָה אֶחָת וּדְבָרִים אֲחָדִים",
            "וַיְהִי בְּנָסְעָם מִקֶּדֶם וַיִּמְצְאוּ בִקְעָה בְּאֶרֶץ שִׁנְעָר וַיֵּשְׁבוּ שָׁם"
        ];
        SETTINGS.textSource = [...DEFAULTS];

        let CONFIG = {
            fontSize: 22, letterSpacing: 16, disruptRadius: 80, maxBodies: 700,
            colors: { english: '#cccccc', hebrew: '#eebb99', shard: '#555', dust: '#777' }
        };
        const GLYPHS = "ΣΩΨΦДЖЊϞϠℵℶℷ∅∇∂≠≡⋈∴∵⌆⌖⌐⌡⌠";

        // --- MATTER.JS SETUP ---
        const Engine = Matter.Engine, Runner = Matter.Runner, Bodies = Matter.Bodies, 
              Composite = Matter.Composite, Constraint = Matter.Constraint, Body = Matter.Body, 
              Mouse = Matter.Mouse, MouseConstraint = Matter.MouseConstraint, Sleeping = Matter.Sleeping;

        const engine = Engine.create({ enableSleeping: true });
        const world = engine.world;
        
        const architectLayer = Composite.create();
        Composite.add(world, architectLayer);

        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        document.body.appendChild(canvas);
        
        engine.positionIterations = 8;
        engine.velocityIterations = 6;

        let width, height;
        let wordComposites = [];
        let particles = [];
        let glitchIntensity = 0;
        let wordQueue = [];
        let walls = []; 
        let dpr = 1;
        let undoStack = []; 
        let currentLineColor = '#ffffff';

        function resize() {
            width = window.innerWidth;
            height = window.innerHeight;
            dpr = window.devicePixelRatio || 1;
            canvas.width = width * dpr;
            canvas.height = height * dpr;
            canvas.style.width = `${width}px`;
            canvas.style.height = `${height}px`;
            ctx.scale(dpr, dpr);

            if (walls.length > 0) Composite.remove(world, walls);
            const floor = Bodies.rectangle(width / 2, height + 100, width * 2, 200, { isStatic: true });
            const wL = Bodies.rectangle(-50, height/2, 100, height*4, { isStatic: true });
            const wR = Bodies.rectangle(width + 50, height/2, 100, height*4, { isStatic: true });
            walls = [floor, wL, wR];
            Composite.add(world, walls);
        }
        window.addEventListener('resize', resize);
        resize();

        const mouse = Mouse.create(canvas);
        mouse.pixelRatio = dpr;
        const mouseConstraint = MouseConstraint.create(engine, {
            mouse: mouse, constraint: { stiffness: 0.1, render: { visible: false } }
        });
        Composite.add(world, mouseConstraint);

        // --- DRAWING & KEYBOARD LOGIC ---
        let isDrawing = false;
        let lastDrawPoint = null;
        let startDrawPoint = null; 
        let currentDrawPoint = null; 
        let hoveredEraseBody = null; 

        document.addEventListener('keydown', (e) => {
            // Undo Logic
            if ((e.ctrlKey || e.metaKey) && e.key === 'z') {
                if (undoStack.length > 0) {
                    const lastBody = undoStack.pop();
                    Composite.remove(architectLayer, lastBody);
                    const nearby = Matter.Query.region(Composite.allBodies(world), lastBody.bounds);
                    nearby.forEach(b => Sleeping.set(b, false));
                }
                return;
            }

            // Typing Mode Logic
            if (SETTINGS.spawnMode === 'typing') {
                const bufferDisplay = document.getElementById('typing-buffer-display');

                if (SETTINGS.typingType === 'char') {
                    // One key = One char
                    if (e.key.length === 1) {
                        triggerSpawn(e.key);
                    }
                } else {
                    // Enter Mode
                    if (e.key === 'Enter') {
                        if (typingBuffer.length > 0) {
                            triggerSpawn(typingBuffer);
                            typingBuffer = "";
                            bufferDisplay.innerText = "";
                        }
                    } else if (e.key === 'Backspace') {
                        typingBuffer = typingBuffer.slice(0, -1);
                        bufferDisplay.innerText = typingBuffer + "_";
                    } else if (e.key.length === 1) {
                        typingBuffer += e.key;
                        bufferDisplay.innerText = typingBuffer + "_";
                    }
                }
            }
        });

        canvas.addEventListener('mousedown', (e) => {
            const clickPoint = { x: e.offsetX, y: e.offsetY };

            // Trigger click-based explosion
            if (SETTINGS.interactionMode === 'shatter' && SETTINGS.triggerMode === 'click') {
                checkShatterAt(clickPoint);
            }

            if (SETTINGS.interactionMode === 'draw') {
                if (SETTINGS.architectTool === 'eraser' && hoveredEraseBody) {
                    Composite.remove(architectLayer, hoveredEraseBody);
                    const idx = undoStack.indexOf(hoveredEraseBody);
                    if (idx > -1) undoStack.splice(idx, 1);
                    hoveredEraseBody = null;
                    return;
                }

                isDrawing = true;
                lastDrawPoint = clickPoint;
                startDrawPoint = clickPoint;
                currentDrawPoint = clickPoint;
            }
        });

        canvas.addEventListener('mouseup', (e) => {
            if (SETTINGS.interactionMode === 'draw' && SETTINGS.architectTool === 'line' && startDrawPoint) {
                let endPoint = { x: e.offsetX, y: e.offsetY };
                if (e.shiftKey) {
                    const dx = Math.abs(endPoint.x - startDrawPoint.x);
                    const dy = Math.abs(endPoint.y - startDrawPoint.y);
                    if (dx > dy) endPoint.y = startDrawPoint.y;
                    else endPoint.x = startDrawPoint.x;
                }
                createStraightLine(startDrawPoint, endPoint);
            }
            isDrawing = false;
            lastDrawPoint = null;
            startDrawPoint = null;
            currentDrawPoint = null;
        });
        
        canvas.addEventListener('mouseleave', () => { isDrawing = false; lastDrawPoint = null; startDrawPoint = null; });
        
        canvas.addEventListener('mousemove', (e) => {
            let pt = { x: e.offsetX, y: e.offsetY };

            // Trigger hover-based explosion
            if (SETTINGS.interactionMode === 'shatter' && SETTINGS.triggerMode === 'hover') {
                checkShatterAt(pt);
            }

            if (SETTINGS.interactionMode === 'draw') {
                if (SETTINGS.architectTool === 'line' && startDrawPoint && e.shiftKey) {
                    const dx = Math.abs(pt.x - startDrawPoint.x);
                    const dy = Math.abs(pt.y - startDrawPoint.y);
                    if (dx > dy) pt.y = startDrawPoint.y;
                    else pt.x = startDrawPoint.x;
                }
                currentDrawPoint = pt;

                if (isDrawing && SETTINGS.architectTool === 'freehand') {
                    const dist = Math.hypot(pt.x - lastDrawPoint.x, pt.y - lastDrawPoint.y);
                    if (dist > 10) {
                        createLineSegment(lastDrawPoint, pt, dist);
                        lastDrawPoint = pt;
                    }
                } 
                
                if (SETTINGS.architectTool === 'eraser') {
                    hoveredEraseBody = null;
                    const bodies = Composite.allBodies(architectLayer);
                    const eraseRadius = 20;
                    
                    for (let b of bodies) {
                        if (Math.abs(b.position.x - pt.x) < 100 && Math.abs(b.position.y - pt.y) < 100) {
                             if (Matter.Vertices.contains(b.vertices, pt) || 
                                Math.hypot(b.position.x - pt.x, b.position.y - pt.y) < eraseRadius) {
                                hoveredEraseBody = b;
                                break;
                            }
                        }
                    }
                }
            }
        });

        function createLineSegment(p1, p2, dist) {
            const angle = Math.atan2(p2.y - p1.y, p2.x - p1.x);
            const midX = (p1.x + p2.x) / 2;
            const midY = (p1.y + p2.y) / 2;
            const body = Bodies.rectangle(midX, midY, dist, SETTINGS.lineThickness, {
                isStatic: true,
                angle: angle,
                friction: SETTINGS.lineFriction,
                render: { visible: true, fillStyle: currentLineColor },
                label: 'drawn-line'
            });
            Composite.add(architectLayer, body);
            undoStack.push(body); 
        }

        function createStraightLine(p1, p2) {
            const dx = p2.x - p1.x;
            const dy = p2.y - p1.y;
            const dist = Math.hypot(dx, dy);
            if (dist < 5) return; 
            createLineSegment(p1, p2, dist);
        }

        // --- GAME LOGIC ---
        function refillQueue() {
            let allWords = [];
            SETTINGS.textSource.forEach(s => allWords = allWords.concat(s.split(/\s+/)));
            wordQueue = allWords;
        }
        refillQueue();

        function createWord(text, x, y) {
            const group = Body.nextGroup(true);
            const letterBodies = [];
            const isHeb = /[\u0590-\u05FF]/.test(text);
            const chars = Array.from(text);
            
            for (let i = 0; i < chars.length; i++) {
                let xPos = isHeb ? x + (chars.length - 1 - i) * CONFIG.letterSpacing : x + (i * CONFIG.letterSpacing);
                const body = Bodies.rectangle(xPos, y, CONFIG.fontSize * 0.5, CONFIG.fontSize, {
                    collisionFilter: { group: group },
                    friction: 0.9, density: 0.02,
                    plugin: { char: chars[i], isBroken: false, color: isHeb ? CONFIG.colors.hebrew : CONFIG.colors.english }
                });
                letterBodies.push(body);
            }
            const constraints = [];
            for (let i = 0; i < letterBodies.length - 1; i++) {
                constraints.push(Constraint.create({
                    bodyA: letterBodies[i], bodyB: letterBodies[i+1],
                    stiffness: 0.8, length: CONFIG.letterSpacing, render: { visible: false }
                }));
            }
            const composite = Composite.create();
            Composite.add(composite, letterBodies);
            Composite.add(composite, constraints);
            composite.plugin = { intact: true };
            return composite;
        }

        let spawnTimer = 0;
        let frameCount = 0;
        
        function triggerSpawn(text) {
            const x = (width/2) + (Math.random()-0.5) * (width*0.6);
            const comp = createWord(text, x, -100);
            Composite.rotate(comp, (Math.random()-0.5), {x:x, y:-100});
            Composite.add(world, comp);
            wordComposites.push(comp);
        }

        function update() {
            frameCount++;
            Engine.update(engine, 1000 / 60);
            engine.world.gravity.y = SETTINGS.gravity;

            mouseConstraint.constraint.stiffness = (SETTINGS.interactionMode === 'drag') ? 0.1 : 0;

            // Only Auto-Spawn if in Auto Mode
            if (SETTINGS.spawnMode === 'auto') {
                if (spawnTimer <= 0) {
                    if (wordQueue.length === 0 && SETTINGS.loop) refillQueue();
                    if (wordQueue.length > 0) {
                        triggerSpawn(wordQueue.shift());
                        spawnTimer = SETTINGS.spawnInterval;
                    }
                }
                spawnTimer--;
            }
            
            garbageCollect();
            draw();
            requestAnimationFrame(update);
        }

        function checkShatterAt(point) {
            wordComposites.forEach(comp => {
                if (!comp.plugin.intact) return;
                const bodies = Composite.allBodies(comp);
                if (!bodies.length) return;
                
                let cx = 0, cy = 0;
                bodies.forEach(b => { cx += b.position.x; cy += b.position.y; });
                cx /= bodies.length; cy /= bodies.length;

                if (Math.hypot(point.x - cx, point.y - cy) < CONFIG.disruptRadius) {
                    shatter(comp, point);
                }
            });
        }

        function shatter(comp, source) {
            comp.plugin.intact = false;
            Composite.remove(comp, Composite.allConstraints(comp)); 
            AudioEngine.triggerBreak((source.x / width) * 2 - 1); 
            
            Composite.allBodies(comp).forEach(b => {
                b.plugin.char = GLYPHS[Math.floor(Math.random() * GLYPHS.length)];
                b.plugin.isBroken = true;
                b.friction = 0.05; 
                b.restitution = 0.1;
                Sleeping.set(b, false);
                let fx = b.position.x - source.x;
                let fy = b.position.y - source.y;
                let len = Math.hypot(fx, fy) || 1;
                const forceMag = SETTINGS.force * b.mass;
                Body.applyForce(b, b.position, { x: (fx/len)*forceMag, y: (fy/len)*forceMag });
                Body.setAngularVelocity(b, (Math.random()-0.5)*0.3);
                
                for(let i=0; i<3; i++) particles.push({
                    x: b.position.x, y: b.position.y,
                    vx: (Math.random()-0.5)*10, vy: (Math.random()-0.5)*10,
                    life: 1.0, size: Math.random()*2+1
                });
            });
            glitchIntensity = 5;
        }

        function garbageCollect() {
            if (frameCount % 60 !== 0) return; 

            const all = Composite.allBodies(world);
            const toRemove = [];
            for (let i = 0; i < all.length; i++) {
                if (all[i].position.y > height + 200) toRemove.push(all[i]);
            }
            Composite.remove(world, toRemove);
            const textBodies = all.filter(b => b.plugin && b.plugin.char);
            if (textBodies.length > CONFIG.maxBodies) {
                const excess = textBodies.slice(0, textBodies.length - CONFIG.maxBodies);
                Composite.remove(world, excess);
            }
        }

        // --- RENDERER ---
        function draw() {
            ctx.clearRect(0,0,width,height);
            if(glitchIntensity > 0.1) {
                ctx.fillStyle = getComputedStyle(document.body).getPropertyValue('--bg');
                ctx.fillRect(0,0,width,height);
            }

            let ox = 0, oy = 0;
            if(glitchIntensity > 0.1) {
                ox = (Math.random()-0.5)*glitchIntensity;
                oy = (Math.random()-0.5)*glitchIntensity;
                glitchIntensity *= 0.9;
            }
            
            ctx.save();
            ctx.translate(ox, oy);

            const bodies = Composite.allBodies(world);
            const architectBodies = Composite.allBodies(architectLayer);
            
            // Draw Architect Lines
            architectBodies.forEach(b => {
                if (b.label === 'drawn-line') {
                    ctx.beginPath();
                    
                    if (b === hoveredEraseBody) {
                        ctx.strokeStyle = '#ff5555';
                        ctx.lineWidth = b.isSensor ? 1 : 2;
                        ctx.moveTo(b.vertices[0].x, b.vertices[0].y);
                        for(let j=1; j<b.vertices.length; j++) ctx.lineTo(b.vertices[j].x, b.vertices[j].y);
                        ctx.lineTo(b.vertices[0].x, b.vertices[0].y);
                        ctx.stroke();
                        ctx.beginPath(); 
                    }

                    ctx.moveTo(b.vertices[0].x, b.vertices[0].y);
                    for(let j=1; j<b.vertices.length; j++) {
                        ctx.lineTo(b.vertices[j].x, b.vertices[j].y);
                    }
                    ctx.lineTo(b.vertices[0].x, b.vertices[0].y);
                    
                    ctx.fillStyle = b.render.fillStyle || '#ffffff';
                    ctx.fill();

                    ctx.beginPath();
                    ctx.strokeStyle = b.render.fillStyle || '#ffffff';
                    ctx.globalAlpha = 0.4;
                    ctx.lineWidth = 1;
                    const jitter = 0.5;
                    ctx.moveTo(b.vertices[0].x + (Math.random()-0.5)*jitter, b.vertices[0].y + (Math.random()-0.5)*jitter);
                    for(let j=1; j<b.vertices.length; j++) {
                       ctx.lineTo(b.vertices[j].x + (Math.random()-0.5)*jitter, b.vertices[j].y + (Math.random()-0.5)*jitter);
                    }
                    ctx.stroke();
                    ctx.globalAlpha = 1.0;
                }
            });

            // Draw Words
            bodies.forEach(b => {
                if (b.plugin && b.plugin.char) {
                    ctx.save();
                    ctx.translate(b.position.x, b.position.y);
                    ctx.rotate(b.angle);
                    ctx.textAlign="center"; ctx.textBaseline="middle";
                    ctx.font = `${CONFIG.fontSize}px 'Courier New'`;
                    
                    const isHebrew = /[\u0590-\u05FF]/.test(b.plugin.char);
                    if (isHebrew && !b.plugin.isBroken) {
                        ctx.shadowColor = CONFIG.colors.hebrew;
                        ctx.shadowBlur = 10; 
                    }

                    if (b.plugin.isBroken) {
                        ctx.fillStyle = CONFIG.colors.shard;
                        if(Math.random()>0.98) ctx.fillStyle='#fff'; 
                    } else {
                        ctx.fillStyle = b.isSleeping ? '#888' : b.plugin.color;
                    }
                    ctx.fillText(b.plugin.char, 0, 0);
                    ctx.shadowBlur = 0;
                    ctx.restore();
                }
            });
            
            // Draw Particles
            for(let i=particles.length-1; i>=0; i--) {
                let p = particles[i];
                p.life -= 0.03;
                if(p.life<=0) particles.splice(i,1);
                else {
                    ctx.fillStyle = CONFIG.colors.dust;
                    ctx.globalAlpha = p.life;
                    ctx.fillRect(p.x, p.y, p.size, p.size);
                    p.x += p.vx; p.y += p.vy;
                }
            }
            ctx.globalAlpha = 1;

            // Draw Tool Overlays
            if (SETTINGS.interactionMode === 'draw' && currentDrawPoint) {
                if (SETTINGS.architectTool === 'line' && isDrawing && startDrawPoint) {
                    ctx.beginPath();
                    ctx.moveTo(startDrawPoint.x, startDrawPoint.y);
                    ctx.lineTo(currentDrawPoint.x, currentDrawPoint.y);
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 1;
                    ctx.setLineDash([5, 5]);
                    ctx.stroke();
                    ctx.setLineDash([]);
                } else if (SETTINGS.architectTool === 'eraser') {
                    ctx.beginPath();
                    ctx.arc(currentDrawPoint.x, currentDrawPoint.y, 20, 0, Math.PI*2);
                    ctx.strokeStyle = hoveredEraseBody ? '#ff5555' : '#777';
                    ctx.lineWidth = hoveredEraseBody ? 2 : 1;
                    ctx.stroke();
                }
            }

            ctx.restore();
        }

        // --- CONTROLS ---
        const panel = document.getElementById('control-panel');
        const trigger = document.getElementById('settings-trigger');
        trigger.addEventListener('click', () => panel.classList.toggle('active'));
        document.addEventListener('click', () => { if(!AudioEngine.initialized) AudioEngine.init(); });

        const bindSlider = (id, settingKey, displayId) => {
            const el = document.getElementById(id);
            const disp = document.getElementById(displayId);
            el.addEventListener('input', (e) => {
                const val = parseFloat(e.target.value);
                SETTINGS[settingKey] = val;
                disp.innerText = val;
            });
        };
        bindSlider('inp-gravity', 'gravity', 'val-gravity');
        bindSlider('inp-force', 'force', 'val-force');
        bindSlider('inp-speed', 'spawnInterval', 'val-speed');
        
        bindSlider('inp-friction', 'lineFriction', 'val-friction');
        bindSlider('inp-thickness', 'lineThickness', 'val-thickness');

        document.getElementById('inp-vol').addEventListener('input', (e) => {
            const val = parseFloat(e.target.value);
            document.getElementById('val-vol').innerText = val;
            AudioEngine.setVolume(val);
        });
        document.getElementById('btn-audio-toggle').addEventListener('click', (e) => {
            e.stopPropagation(); 
            AudioEngine.toggle();
        });

        // Mode Toggles
        const btnDrag = document.getElementById('btn-mode-drag');
        const btnShatter = document.getElementById('btn-mode-shatter');
        const btnDraw = document.getElementById('btn-mode-draw');
        
        const setMode = (mode) => {
            SETTINGS.interactionMode = mode;
            btnDrag.classList.toggle('active', mode === 'drag');
            btnShatter.classList.toggle('active', mode === 'shatter');
            btnDraw.classList.toggle('active', mode === 'draw');
            
            document.body.classList.remove('mode-drag', 'mode-shatter', 'mode-draw');
            document.body.classList.add(`mode-${mode}`);
        };

        btnDrag.addEventListener('click', () => setMode('drag'));
        btnShatter.addEventListener('click', () => setMode('shatter'));
        btnDraw.addEventListener('click', () => setMode('draw'));

        // Architect Sub-Tools
        const btnToolFree = document.getElementById('btn-tool-free');
        const btnToolLine = document.getElementById('btn-tool-line');
        const btnToolErase = document.getElementById('btn-tool-erase');

        const setArchitectTool = (tool) => {
            SETTINGS.architectTool = tool;
            btnToolFree.classList.toggle('active', tool === 'freehand');
            btnToolLine.classList.toggle('active', tool === 'line');
            btnToolErase.classList.toggle('active', tool === 'eraser');
            
            document.body.classList.remove('tool-free', 'tool-line', 'tool-erase');
            document.body.classList.add(`tool-${tool}`);
        };

        btnToolFree.addEventListener('click', () => setArchitectTool('freehand'));
        btnToolLine.addEventListener('click', () => setArchitectTool('line'));
        btnToolErase.addEventListener('click', () => setArchitectTool('eraser'));
        document.body.classList.add('tool-free');

        // Trigger Mode Toggles
        const btnTrigClick = document.getElementById('btn-trigger-click');
        const btnTrigHover = document.getElementById('btn-trigger-hover');

        btnTrigClick.addEventListener('click', () => {
            SETTINGS.triggerMode = 'click';
            btnTrigClick.classList.add('active');
            btnTrigHover.classList.remove('active');
        });
        btnTrigHover.addEventListener('click', () => {
            SETTINGS.triggerMode = 'hover';
            btnTrigHover.classList.add('active');
            btnTrigClick.classList.remove('active');
        });

        // --- NEW SPAWN MODE TOGGLES ---
        const btnSpawnAuto = document.getElementById('btn-spawn-auto');
        const btnSpawnType = document.getElementById('btn-spawn-type');
        const typingSettingsDiv = document.getElementById('typing-settings');
        
        btnSpawnAuto.addEventListener('click', () => {
            SETTINGS.spawnMode = 'auto';
            btnSpawnAuto.classList.add('active');
            btnSpawnType.classList.remove('active');
            typingSettingsDiv.style.display = 'none';
        });

        btnSpawnType.addEventListener('click', () => {
            SETTINGS.spawnMode = 'typing';
            btnSpawnType.classList.add('active');
            btnSpawnAuto.classList.remove('active');
            typingSettingsDiv.style.display = 'flex';
            typingBuffer = "";
            document.getElementById('typing-buffer-display').innerText = "";
        });

        const btnTypeChar = document.getElementById('btn-type-char');
        const btnTypeEnter = document.getElementById('btn-type-enter');
        const typeDesc = document.getElementById('type-desc');

        btnTypeChar.addEventListener('click', () => {
            SETTINGS.typingType = 'char';
            btnTypeChar.classList.add('active');
            btnTypeEnter.classList.remove('active');
            typeDesc.innerText = "Press any key to drop a character.";
            typingBuffer = "";
            document.getElementById('typing-buffer-display').innerText = "";
        });

        btnTypeEnter.addEventListener('click', () => {
            SETTINGS.typingType = 'enter';
            btnTypeEnter.classList.add('active');
            btnTypeChar.classList.remove('active');
            typeDesc.innerText = "Type a word, then press ENTER to drop.";
        });

        document.getElementById('btn-update-text').addEventListener('click', () => {
            const raw = document.getElementById('inp-text').value;
            if (raw.trim().length > 0) {
                SETTINGS.textSource = [raw];
                refillQueue();
            }
        });

        document.getElementById('btn-clear').addEventListener('click', () => {
            Composite.clear(world, false, true); 
            resize(); 
            wordComposites = [];
            refillQueue();
            undoStack = [];
            particles = [];
        });
        document.getElementById('inp-loop').addEventListener('change', (e) => SETTINGS.loop = e.target.checked);

        // --- NEW FEATURES IMPLEMENTATION ---

        // 1. SWEEP DEBRIS
        document.getElementById('btn-sweep').addEventListener('click', () => {
            const all = Composite.allBodies(world);
            const debris = all.filter(b => b.plugin && b.plugin.isBroken);
            Composite.remove(world, debris);
            particles = []; 
        });

        // 2. SAVE LAYOUT
        document.getElementById('btn-save').addEventListener('click', () => {
            const lines = Composite.allBodies(architectLayer).map(b => {
                const len = Math.hypot(b.vertices[1].x - b.vertices[0].x, b.vertices[1].y - b.vertices[0].y);
                return { 
                    x: b.position.x, 
                    y: b.position.y, 
                    angle: b.angle, 
                    length: len,
                    color: b.render.fillStyle || '#ffffff' 
                };
            });

            localStorage.setItem('babel_architect_v1', JSON.stringify(lines));
            
            const btn = document.getElementById('btn-save');
            const original = btn.innerText;
            btn.innerText = "SAVED!";
            setTimeout(() => btn.innerText = original, 1000);
        });

        // 3. LOAD LAYOUT
        document.getElementById('btn-load').addEventListener('click', () => {
            const raw = localStorage.getItem('babel_architect_v1');
            if (!raw) return;
            
            Composite.clear(architectLayer, false, true);
            undoStack = [];

            const data = JSON.parse(raw);
            data.forEach(lineData => {
                const body = Bodies.rectangle(lineData.x, lineData.y, lineData.length, SETTINGS.lineThickness, {
                    isStatic: true,
                    angle: lineData.angle,
                    friction: SETTINGS.lineFriction,
                    render: { visible: true, fillStyle: lineData.color || '#ffffff' },
                    label: 'drawn-line'
                });
                Composite.add(architectLayer, body);
                undoStack.push(body);
            });
        });

        // 4. VISUAL SETTINGS LISTENERS
        const inpFontSize = document.getElementById('inp-fontsize');
        inpFontSize.addEventListener('change', (e) => {
            CONFIG.fontSize = parseInt(e.target.value);
            CONFIG.letterSpacing = CONFIG.fontSize * 0.7; 
            document.getElementById('val-fontsize').innerText = CONFIG.fontSize;
            Composite.clear(world, false, true);
            wordComposites = [];
            refillQueue();
        });
        inpFontSize.addEventListener('input', (e) => {
             document.getElementById('val-fontsize').innerText = e.target.value;
        });

        const colorBtns = document.querySelectorAll('#line-color-picker button');
        colorBtns.forEach(btn => {
            btn.addEventListener('click', () => {
                colorBtns.forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                currentLineColor = btn.getAttribute('data-col');
            });
        });

        document.getElementById('btn-load-bg').addEventListener('click', () => {
            const url = document.getElementById('inp-bg-url').value;
            if(url) document.getElementById('bg-reference').style.backgroundImage = `url('${url}')`;
        });
        document.getElementById('btn-clear-bg').addEventListener('click', () => {
            document.getElementById('bg-reference').style.backgroundImage = '';
            document.getElementById('inp-bg-url').value = '';
        });

        update();

    </script>
</body>
</html>