<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Fall of Babel: Architect Mode VII (Typist)</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <style>
        :root {
            --bg: #050505;
            --text: #cccccc;
            --accent: #eebb99; /* Hebrew Gold */
            --panel-bg: rgba(10, 10, 10, 0.90);
            --border: #333;
            --danger: #ff5555;
            --active-tab: #222;
        }
        body {
            margin: 0; padding: 0; overflow: hidden;
            background-color: var(--bg);
            color: var(--text);
            font-family: 'Courier New', Courier, monospace;
            user-select: none;
        }
        canvas { display: block; position: relative; z-index: 1; }
        
        /* Cursor styling */
        body.mode-drag canvas { cursor: grab; }
        body.mode-drag canvas:active { cursor: grabbing; }
        body.mode-shatter canvas { cursor: crosshair; }
        
        body.mode-draw.tool-free canvas { cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2"><path d="M12 19l7-7 3 3-7 7-3-3z"/><path d="M18 13l-1.5-7.5L2 2l3.5 14.5L13 18l5-5z"/><path d="M2 2l7.586 7.586"/><circle cx="11" cy="11" r="2"/></svg>') 0 24, auto; }
        body.mode-draw.tool-line canvas { cursor: crosshair; }
        body.mode-draw.tool-erase canvas { cursor: cell; }
        body.mode-draw.tool-fan canvas { cursor: crosshair; }

        /* --- UI LAYER --- */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 10;
        }

        /* Background Reference Layer */
        #bg-reference {
            position: absolute; top:0; left:0; width:100%; height:100%;
            background-size: contain; background-repeat: no-repeat; background-position: center;
            opacity: 0.3; pointer-events: none; z-index: 0;
        }

        #settings-trigger {
            position: absolute; top: 20px; right: 20px;
            font-size: 24px; cursor: pointer; pointer-events: auto;
            color: #444; transition: color 0.3s, transform 0.5s;
            z-index: 100;
        }
        #settings-trigger:hover { color: var(--text); transform: rotate(90deg); }

        /* --- NEW CONTROL PANEL LAYOUT --- */
        #control-panel {
            position: absolute; top: 0; right: 0;
            width: 360px; height: 100%;
            background: var(--panel-bg);
            border-left: 1px solid var(--border);
            backdrop-filter: blur(10px);
            transform: translateX(100%);
            transition: transform 0.4s cubic-bezier(0.16, 1, 0.3, 1);
            pointer-events: auto;
            display: flex; flex-direction: column;
        }
        #control-panel.active { transform: translateX(0); }

        /* Fixed Header Area */
        .panel-header {
            padding: 20px 20px 10px 20px;
            border-bottom: 1px solid var(--border);
            flex-shrink: 0;
        }

        /* Tabs Navigation */
        .tabs-nav {
            display: flex;
            background: #000;
            border-bottom: 1px solid var(--border);
        }
        .tabs-nav button {
            flex: 1; border: none; background: transparent;
            padding: 12px 0; font-size: 11px; color: #666;
            cursor: pointer; border-bottom: 2px solid transparent;
            transition: all 0.2s;
        }
        .tabs-nav button:hover { color: #aaa; background: #111; }
        .tabs-nav button.active { 
            color: var(--accent); border-bottom: 2px solid var(--accent); background: #0a0a0a; 
        }

        /* Scrollable Content Area */
        .panel-content {
            flex: 1; overflow-y: auto; padding: 20px;
            position: relative;
        }

        /* Tab Contents */
        .tab-section { display: none; flex-direction: column; gap: 25px; animation: fadeIn 0.3s ease; }
        .tab-section.active { display: flex; }

        @keyframes fadeIn { from { opacity: 0; transform: translateY(5px); } to { opacity: 1; transform: translateY(0); } }

        /* Standard Controls */
        h2 { 
            font-size: 10px; border-bottom: 1px solid var(--border); 
            padding-bottom: 5px; margin: 0 0 10px 0; color: #666; letter-spacing: 2px; 
        }
        
        .control-group { display: flex; flex-direction: column; gap: 8px; margin-bottom: 5px; }
        .label-row { display: flex; justify-content: space-between; font-size: 10px; color: #888; }
        
        input[type="range"] { -webkit-appearance: none; width: 100%; background: transparent; }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none; height: 12px; width: 4px;
            background: var(--accent); cursor: ew-resize; margin-top: -5px;
            box-shadow: 0 0 10px rgba(238, 187, 153, 0.5);
        }
        input[type="range"]::-webkit-slider-runnable-track { width: 100%; height: 2px; background: #333; }

        textarea {
            background: #080808; border: 1px solid var(--border);
            color: var(--text); width: 100%; height: 60px;
            font-family: inherit; font-size: 10px; padding: 10px;
            resize: vertical; outline: none;
        }
        
        button {
            background: transparent; border: 1px solid var(--border);
            color: var(--text); padding: 10px; font-family: inherit;
            cursor: pointer; font-size: 10px; transition: all 0.2s;
            letter-spacing: 1px;
        }
        button:hover { background: #222; border-color: var(--text); }
        button.active { border-color: var(--accent); color: var(--accent); background: rgba(238, 187, 153, 0.1); }
        
        .mode-toggle-group { display: flex; gap: 5px; }
        .mode-toggle-group button { flex: 1; font-size: 9px; padding: 10px 5px; }

        /* Color Picker Buttons */
        #line-color-picker button { flex:1; height:20px; border:1px solid #333; }
        #line-color-picker button:hover { opacity: 0.8; }
        #line-color-picker button.active { border:2px solid #fff; transform:scale(1.1); box-shadow: 0 0 10px rgba(255,255,255,0.2); }

        #architect-controls { display: none; margin-top: 10px; padding-top: 10px; border-top: 1px dashed #333; }
        .mode-draw #architect-controls { display: flex; }

        #audio-status {
            position: absolute; bottom: 20px; left: 20px;
            font-size: 10px; color: var(--accent); letter-spacing: 1px;
            opacity: 0; transition: opacity 1s;
        }

        #tooltip {
            position: absolute; top: 20px; left: 20px;
            font-size: 11px; color: #666;
            pointer-events: none;
            display: none;
            z-index: 20;
        }
        .mode-draw #tooltip { display: block; }

        /* Typing Buffer Visual */
        #typing-buffer-display {
            position: absolute; top: 50px; left: 20px;
            font-size: 14px; color: var(--accent);
            opacity: 0.7; pointer-events: none;
        }

        .vignette {
            position: absolute; top:0; left:0; width:100%; height:100%;
            background: radial-gradient(circle, transparent 40%, black 140%);
            pointer-events: none;
            z-index: 5;
        }
        .grain {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            opacity: 0.05; pointer-events: none;
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.85' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)'/%3E%3C/svg%3E");
            animation: grain 1s steps(10) infinite;
            z-index: 5;
        }
        @keyframes grain { 0%, 100% {transform:translate(0,0)} 20% {transform:translate(-2px,2px)} 40% {transform:translate(2px,-2px)} 60% {transform:translate(-2px,-2px)} 80% {transform:translate(2px,2px)} }
    </style>
</head>
<body class="mode-shatter">

    <div id="ui-layer">
        <div id="bg-reference"></div>
        <div class="grain"></div>
        <div class="vignette"></div>
        <div id="audio-status">AUDIO ENGINE :: ONLINE</div>
        <div id="tooltip">[SHIFT] Snap Axis • [CTRL+Z] Undo</div>
        <div id="typing-buffer-display"></div>
        <div id="settings-trigger">[ ☼ ]</div>
        
        <div id="control-panel">
            
            <div class="panel-header">
                <h2>CURSOR MODE</h2>
                <div class="control-group mode-toggle-group">
                    <button id="btn-mode-drag">MANIPULATE</button>
                    <button id="btn-mode-shatter" class="active">DISRUPT</button>
                    <button id="btn-mode-draw">ARCHITECT</button>
                </div>
                <div id="architect-controls" class="control-group">
                    <div class="label-row" style="margin-bottom:5px;"><span>TOOL</span></div>
                    <div class="mode-toggle-group">
                        <button id="btn-tool-free" class="active">FREE</button>
                        <button id="btn-tool-line">LINE</button>
                        <button id="btn-tool-fan">FAN</button>
                        <button id="btn-tool-erase">ERASE</button>
                    </div>
                </div>
            </div>

            <div class="tabs-nav">
                <button class="tab-btn active" data-target="tab-sim">SIM</button>
                <button class="tab-btn" data-target="tab-arch">ARCH</button>
                <button class="tab-btn" data-target="tab-vis">VIS</button>
                <button class="tab-btn" data-target="tab-data">DATA</button>
            </div>

            <div class="panel-content">
                
                <div id="tab-sim" class="tab-section active">
                    <h2>SPAWN MODE</h2>
                    <div class="control-group mode-toggle-group">
                        <button id="btn-spawn-auto" class="active">AUTO DROP</button>
                        <button id="btn-spawn-type">TYPE INPUT</button>
                    </div>
                    
                    <div id="typing-settings" class="control-group" style="display:none; margin-top:5px; border-top:1px dashed #333; padding-top:10px;">
                        <div class="label-row" style="margin-bottom:5px;"><span>INPUT METHOD</span></div>
                        <div class="mode-toggle-group">
                            <button id="btn-type-char" class="active">1 KEY = 1 CHAR</button>
                            <button id="btn-type-enter">DROP ON ENTER</button>
                        </div>
                        <div style="font-size:9px; color:#666; margin-top:5px;">
                            <span id="type-desc">Press any key to drop a character.</span>
                        </div>
                    </div>

                    <h2>INTERACTION TRIGGER</h2>
                    <div class="control-group mode-toggle-group">
                        <button id="btn-trigger-click" class="active">CLICK</button>
                        <button id="btn-trigger-hover">HOVER</button>
                    </div>

                    <h2>PHYSICS</h2>
                    <div class="control-group">
                        <div class="label-row"><span>GRAVITY</span><span id="val-gravity">1.0</span></div>
                        <input type="range" id="inp-gravity" min="0" max="2" step="0.1" value="1">
                    </div>
                    <div class="control-group">
                        <div class="label-row"><span>FORCE</span><span id="val-force">0.12</span></div>
                        <input type="range" id="inp-force" min="0.01" max="0.5" step="0.01" value="0.12">
                    </div>

                    <h2>FLOW (AUTO MODE)</h2>
                    <div class="control-group">
                        <div class="label-row"><span>DELAY</span><span id="val-speed">35</span></div>
                        <input type="range" id="inp-speed" min="5" max="100" step="1" value="35">
                    </div>
                    <div class="control-group" style="flex-direction:row; justify-content:space-between; align-items:center;">
                        <span style="font-size:10px; color:#888;">INFINITE LOOP</span>
                        <input type="checkbox" id="inp-loop" checked style="width:auto; margin:0;">
                    </div>

                    <h2>MAINTENANCE</h2>
                    <button id="btn-sweep" style="color:#eebb99; border-color:#664422;">SWEEP DEBRIS</button>
                    <button id="btn-clear" style="color:#ff6666; border-color:#663333;">PURGE ALL</button>
                </div>

                <div id="tab-arch" class="tab-section">
                    <h2>BLUEPRINT</h2>
                    <div class="control-group" style="display:flex; flex-direction:row; gap:5px;">
                        <button id="btn-save" style="flex:1;">SAVE LAYOUT</button>
                        <button id="btn-load" style="flex:1;">LOAD LAYOUT</button>
                    </div>

                    <h2>LINE TYPE</h2>
                    <div class="control-group mode-toggle-group">
                        <button id="btn-line-standard" class="active">STANDARD</button>
                        <button id="btn-line-kill" style="color:#ff7777;">KILL ZONE</button>
                        <button id="btn-line-bounce" style="color:#77aaff;">BOUNCE PAD</button>
                    </div>
                    <div style="font-size:9px; color:#666;">Kill zones vaporize text; bounce pads add 1.5x restitution.</div>

                    <h2>LINE PROPERTIES</h2>
                    <div class="control-group">
                        <div class="label-row"><span>FRICTION</span><span id="val-friction">0.1</span></div>
                        <input type="range" id="inp-friction" min="0" max="1" step="0.05" value="0.1">
                    </div>
                    <div class="control-group">
                        <div class="label-row"><span>THICKNESS</span><span id="val-thickness">4</span></div>
                        <input type="range" id="inp-thickness" min="2" max="40" step="1" value="4">
                    </div>

                    <h2>WIND</h2>
                    <div class="control-group">
                        <div class="label-row"><span>FAN DIRECTION</span></div>
                        <div class="mode-toggle-group">
                            <button id="btn-fan-left">←</button>
                            <button id="btn-fan-up" class="active">↑</button>
                            <button id="btn-fan-right">→</button>
                            <button id="btn-fan-down">↓</button>
                        </div>
                    </div>
                    <div class="control-group">
                        <div class="label-row"><span>FAN STRENGTH</span><span id="val-fan-strength">0.0006</span></div>
                        <input type="range" id="inp-fan-strength" min="0" max="0.002" step="0.0001" value="0.0006">
                    </div>
                </div>

                <div id="tab-vis" class="tab-section">
                    <h2>TYPOGRAPHY</h2>
                    <div class="control-group">
                        <div class="label-row"><span>TEXT SIZE (RESETS)</span><span id="val-fontsize">22</span></div>
                        <input type="range" id="inp-fontsize" min="10" max="60" step="2" value="22">
                    </div>

                    <h2>PALETTE</h2>
                    <div class="control-group">
                        <div class="label-row"><span>LINE COLOR</span></div>
                        <div class="mode-toggle-group" id="line-color-picker">
                            <button data-col="#ffffff" style="background:#fff;" class="active"></button>
                            <button data-col="#eebb99" style="background:#eebb99;"></button>
                            <button data-col="#ff5555" style="background:#ff5555;"></button>
                            <button data-col="#5555ff" style="background:#5555ff;"></button>
                        </div>
                    </div>

                    <h2>REFERENCE</h2>
                    <div class="control-group">
                        <div class="label-row"><span>IMAGE URL</span></div>
                        <textarea id="inp-bg-url" placeholder="Paste image URL..." style="height:30px;"></textarea>
                        <div class="mode-toggle-group">
                            <button id="btn-load-bg">LOAD</button>
                            <button id="btn-clear-bg">CLEAR</button>
                        </div>
                    </div>
                </div>

                <div id="tab-data" class="tab-section">
                    <h2>AUDIO</h2>
                    <div class="control-group">
                        <button id="btn-audio-toggle">INITIALIZE AUDIO</button>
                    </div>
                    <div class="control-group">
                        <div class="label-row"><span>VOLUME</span><span id="val-vol">0.5</span></div>
                        <input type="range" id="inp-vol" min="0" max="1" step="0.05" value="0.5">
                    </div>

                    <h2>SOURCE TEXT</h2>
                    <div class="control-group">
                        <textarea id="inp-text" placeholder="Paste custom text..."></textarea>
                        <button id="btn-update-text">INJECT NEW STREAM</button>
                    </div>
                </div>

            </div>
        </div>
    </div>

    <script>
        // --- TAB SYSTEM LOGIC ---
        const tabBtns = document.querySelectorAll('.tab-btn');
        const tabSections = document.querySelectorAll('.tab-section');

        tabBtns.forEach(btn => {
            btn.addEventListener('click', () => {
                tabBtns.forEach(b => b.classList.remove('active'));
                tabSections.forEach(s => s.classList.remove('active'));
                btn.classList.add('active');
                const target = document.getElementById(btn.dataset.target);
                if(target) target.classList.add('active');
            });
        });

        class Particle {
            constructor(x, y) {
                this.x = x; this.y = y;
                this.vx = (Math.random()-0.5)*10;
                this.vy = (Math.random()-0.5)*10;
                this.life = 1.0;
                this.size = Math.random()*2+1;
            }
            update() {
                this.life -= 0.03;
                this.x += this.vx; this.y += this.vy;
                return this.life > 0;
            }
            draw(ctx, color) {
                ctx.fillStyle = color;
                ctx.globalAlpha = this.life;
                ctx.fillRect(this.x, this.y, this.size, this.size);
                ctx.globalAlpha = 1;
            }
        }

        class AudioEngine {
            constructor() {
                this.ctx = null;
                this.masterGain = null;
                this.initialized = false;
                this.droneVoices = [];
                this.tension = 0;
            }
            init() {
                if (this.initialized) return;
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                this.ctx = new AudioContext();
                const compressor = this.ctx.createDynamicsCompressor();
                compressor.threshold.setValueAtTime(-24, this.ctx.currentTime);
                compressor.knee.setValueAtTime(30, this.ctx.currentTime);
                compressor.ratio.setValueAtTime(12, this.ctx.currentTime);
                compressor.attack.setValueAtTime(0.003, this.ctx.currentTime);
                compressor.release.setValueAtTime(0.25, this.ctx.currentTime);
                this.masterGain = this.ctx.createGain();
                this.masterGain.gain.value = 0.5;
                this.masterGain.connect(compressor);
                compressor.connect(this.ctx.destination);
                this.initialized = true;
                this.startDrone();
                this.updateUI(true);
                const status = document.getElementById('audio-status');
                status.style.opacity = 0.6;
                setTimeout(() => status.style.opacity = 0, 4000);
            }
            toggle() {
                if (!this.initialized) { this.init(); return; }
                if (this.ctx.state === 'running') { this.ctx.suspend(); this.updateUI(false); } 
                else if (this.ctx.state === 'suspended') { this.ctx.resume(); this.updateUI(true); }
            }
            updateUI(active) {
                const btn = document.getElementById('btn-audio-toggle');
                if (active) { btn.innerText = "AUDIO :: ACTIVE"; btn.classList.add('active'); } 
                else { btn.innerText = "AUDIO :: SUSPENDED"; btn.classList.remove('active'); }
            }
            setVolume(val) { if(this.masterGain) this.masterGain.gain.setValueAtTime(val, this.ctx.currentTime); }
            startDrone() {
                [55, 65, 110, 220].forEach((f, i) => {
                    const osc = this.ctx.createOscillator();
                    const gain = this.ctx.createGain();
                    osc.type = i === 1 ? 'sine' : 'triangle'; 
                    osc.frequency.value = f;
                    const lfo = this.ctx.createOscillator();
                    lfo.frequency.value = 0.05 + Math.random() * 0.05;
                    const lfoGain = this.ctx.createGain();
                    lfoGain.gain.value = 0.01;
                    lfo.connect(lfoGain); lfoGain.connect(gain.gain);
                    gain.gain.value = 0.04; 
                    osc.connect(gain); gain.connect(this.masterGain); 
                    osc.start(); lfo.start();
                    this.droneVoices.push({ osc, gain, baseFreq: f });
                });
            }
            setTension(level) {
                if (!this.initialized || this.ctx.state === 'suspended') return;
                this.tension = Math.max(0, Math.min(1, level));
                const spread = 1 + this.tension * 1.5;
                const now = this.ctx.currentTime;
                this.droneVoices.forEach((voice, idx) => {
                    const offset = (idx - 1.5) * 0.02;
                    voice.osc.frequency.setTargetAtTime(voice.baseFreq * spread * (1 + offset), now, 0.2);
                    voice.gain.gain.setTargetAtTime(0.02 + this.tension * 0.04, now, 0.2);
                });
            }
            triggerBreak(panX) {
                if (!this.initialized || this.ctx.state === 'suspended') return;
                const t = this.ctx.currentTime;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                const panner = this.ctx.createStereoPanner();
                osc.frequency.setValueAtTime(400 + Math.random()*1000, t);
                osc.frequency.exponentialRampToValueAtTime(10, t + 0.15);
                gain.gain.setValueAtTime(0.3 * SETTINGS.force, t); 
                gain.gain.exponentialRampToValueAtTime(0.001, t + 0.15);
                panner.pan.value = panX;
                osc.connect(gain); gain.connect(panner); panner.connect(this.masterGain);
                osc.start(); osc.stop(t + 0.2);
            }
            click() {
                if (!this.initialized || this.ctx.state === 'suspended') return;
                const t = this.ctx.currentTime;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = 'square';
                osc.frequency.setValueAtTime(900, t);
                osc.frequency.exponentialRampToValueAtTime(1200, t + 0.02);
                gain.gain.setValueAtTime(0.08, t);
                gain.gain.exponentialRampToValueAtTime(0.0001, t + 0.05);
                osc.connect(gain); gain.connect(this.masterGain);
                osc.start(t); osc.stop(t + 0.06);
            }
        }
        const audioEngine = new AudioEngine();

        // --- GLOBAL SETTINGS ---
        const SETTINGS = {
            gravity: 1.0,
            force: 0.05,
            spawnInterval: 35,
            loop: true,
            interactionMode: 'shatter', 
            architectTool: 'freehand', 
            triggerMode: 'hover', // 'click' or 'hover'
            spawnMode: 'auto', // 'auto' or 'typing'
            typingType: 'char', // 'char' or 'enter'
            textSource: [],
            lineFriction: 0.1,
            lineThickness: 4,
            lineType: 'standard',
            fanStrength: 0.0006,
            fanRadius: 180,
            fanDirection: { x: 0, y: -1 }
        };

        let typingBuffer = "";
        let enterHoldStart = null;

        const DEFAULTS = [
            "Now the whole earth had one language and the same words.",
            "And as people migrated from the east, they found a plain in the land of Shinar and settled there.",
            "And they said to one another, Come, let us make bricks, and burn them thoroughly.",
            "Then they said, Come, let us build ourselves a city and a tower with its top in the heavens.",
            "And the Lord came down to see the city and the tower, which the children of man had built.",
            "And the Lord said, Behold, they are one people, and they have all one language.",
            "Come, let us go down and there confuse their language.",
            "So the Lord dispersed them from there over the face of all the earth.",
            "Therefore its name was called Babel, because there the Lord confused the language of all the earth.",
            "וַיְהִי כָל-הָאָרֶץ שָׂפָה אֶחָת וּדְבָרִים אֲחָדִים",
            "וַיְהִי בְּנָסְעָם מִקֶּדֶם וַיִּמְצְאוּ בִקְעָה בְּאֶרֶץ שִׁנְעָר וַיֵּשְׁבוּ שָׁם"
        ];
        SETTINGS.textSource = [...DEFAULTS];

        let CONFIG = {
            fontSize: 22, letterSpacing: 16, disruptRadius: 80, maxBodies: 700,
            colors: { 
                english: '#cccccc', hebrew: '#eebb99', shard: '#555', dust: '#777',
                kill: '#ff5555', bounce: '#5b8dff', line: '#ffffff'
            },
            capitalMassBoost: 1.5,
            capitalSizeBoost: 1.15
        };
        const GLYPHS = "ΣΩΨΦДЖЊϞϠℵℶℷ∅∇∂≠≡⋈∴∵⌆⌖⌐⌡⌠";

        // --- MATTER.JS SETUP ---
        const Engine = Matter.Engine, Runner = Matter.Runner, Bodies = Matter.Bodies, 
              Composite = Matter.Composite, Constraint = Matter.Constraint, Body = Matter.Body, 
              Mouse = Matter.Mouse, MouseConstraint = Matter.MouseConstraint, Sleeping = Matter.Sleeping,
              Events = Matter.Events;

        class WordFactory {
            constructor(config) {
                this.config = config;
            }
            isUpperCase(ch) {
                return ch === ch.toUpperCase() && ch !== ch.toLowerCase();
            }
            create(text, x, y, options = {}) {
                const group = Body.nextGroup(true);
                const letterBodies = [];
                const isHeb = /[\u0590-\u05FF]/.test(text);
                const chars = Array.from(text);
                const massScale = options.massScale || 1;
                const sizeScale = options.sizeScale || 1;
                
                for (let i = 0; i < chars.length; i++) {
                    const ch = chars[i];
                    const sizeBoost = this.isUpperCase(ch) ? this.config.capitalSizeBoost : 1;
                    const massBoost = this.isUpperCase(ch) ? this.config.capitalMassBoost : 1;
                    const height = this.config.fontSize * sizeScale * sizeBoost;
                    const width = height * 0.5;
                    const xPos = isHeb ? x + (chars.length - 1 - i) * this.config.letterSpacing : x + (i * this.config.letterSpacing);
                    const body = Bodies.rectangle(xPos, y, width, height, {
                        collisionFilter: { group },
                        friction: 0.9, 
                        density: 0.02 * massScale * massBoost,
                        plugin: { 
                            char: ch, isBroken: false, 
                            color: isHeb ? this.config.colors.hebrew : this.config.colors.english,
                            size: height
                        }
                    });
                    letterBodies.push(body);
                }

                const constraints = [];
                for (let i = 0; i < letterBodies.length - 1; i++) {
                    constraints.push(Constraint.create({
                        bodyA: letterBodies[i], bodyB: letterBodies[i+1],
                        stiffness: 0.8, length: this.config.letterSpacing, render: { visible: false }
                    }));
                }
                const composite = Composite.create({ label: 'word' });
                Composite.add(composite, letterBodies);
                Composite.add(composite, constraints);
                composite.plugin = { intact: true, text };
                letterBodies.forEach(b => { b.plugin.wordComposite = composite; });
                return composite;
            }
        }

        const engine = Engine.create({ enableSleeping: true });
        const world = engine.world;
        
        const architectLayer = Composite.create();
        Composite.add(world, architectLayer);

        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        document.body.appendChild(canvas);
        
        engine.positionIterations = 8;
        engine.velocityIterations = 6;

        let width, height;
        let wordComposites = [];
        let particles = [];
        let fanFields = [];
        let glitchIntensity = 0;
        let wordQueue = [];
        let walls = []; 
        let dpr = 1;
        let undoStack = []; 
        let currentLineColor = CONFIG.colors.line;
        const wordFactory = new WordFactory(CONFIG);

        function resize() {
            width = window.innerWidth;
            height = window.innerHeight;
            dpr = window.devicePixelRatio || 1;
            canvas.width = width * dpr;
            canvas.height = height * dpr;
            canvas.style.width = `${width}px`;
            canvas.style.height = `${height}px`;
            ctx.scale(dpr, dpr);

            if (walls.length > 0) Composite.remove(world, walls);
            const floor = Bodies.rectangle(width / 2, height + 100, width * 2, 200, { isStatic: true });
            const wL = Bodies.rectangle(-50, height/2, 100, height*4, { isStatic: true });
            const wR = Bodies.rectangle(width + 50, height/2, 100, height*4, { isStatic: true });
            walls = [floor, wL, wR];
            Composite.add(world, walls);
        }
        window.addEventListener('resize', resize);
        resize();

        const mouse = Mouse.create(canvas);
        mouse.pixelRatio = dpr;
        const mouseConstraint = MouseConstraint.create(engine, {
            mouse: mouse, constraint: { stiffness: 0.1, render: { visible: false } }
        });
        Composite.add(world, mouseConstraint);

        // --- DRAWING & KEYBOARD LOGIC ---
        mouseConstraint.constraint.stiffness = 0;

        class InteractionState {
            enter() {}
            exit() {}
            onMouseDown() {}
            onMouseUp() {}
            onMouseMove() {}
            onMouseLeave() {}
            onKeyDown() {}
            onKeyUp() {}
        }

        class ShatterState extends InteractionState {
            onMouseDown(e) {
                if (SETTINGS.triggerMode === 'click') {
                    checkShatterAt({ x: e.offsetX, y: e.offsetY });
                }
            }
            onMouseMove(e) {
                if (SETTINGS.triggerMode === 'hover') {
                    checkShatterAt({ x: e.offsetX, y: e.offsetY });
                }
            }
        }

        class DragState extends InteractionState {
            enter() { mouseConstraint.constraint.stiffness = 0.1; }
            exit() { mouseConstraint.constraint.stiffness = 0; }
        }

        class DrawState extends InteractionState {
            constructor() {
                super();
                this.reset();
            }
            reset() {
                this.isDrawing = false;
                this.lastPoint = null;
                this.startPoint = null;
                this.currentPoint = null;
                this.hoveredEraseBody = null;
            }
            onMouseDown(e) {
                const pt = { x: e.offsetX, y: e.offsetY };
                if (SETTINGS.architectTool === 'eraser' && this.hoveredEraseBody) {
                    removeArchitectBody(this.hoveredEraseBody);
                    this.hoveredEraseBody = null;
                    return;
                }
                if (SETTINGS.architectTool === 'fan') {
                    createFan(pt);
                    return;
                }
                this.isDrawing = true;
                this.lastPoint = pt;
                this.startPoint = pt;
                this.currentPoint = pt;
            }
            onMouseMove(e) {
                let pt = { x: e.offsetX, y: e.offsetY };
                if (SETTINGS.architectTool === 'line' && this.startPoint && e.shiftKey) {
                    const dx = Math.abs(pt.x - this.startPoint.x);
                    const dy = Math.abs(pt.y - this.startPoint.y);
                    if (dx > dy) pt.y = this.startPoint.y;
                    else pt.x = this.startPoint.x;
                }
                this.currentPoint = pt;

                if (this.isDrawing && SETTINGS.architectTool === 'freehand') {
                    const dist = Math.hypot(pt.x - this.lastPoint.x, pt.y - this.lastPoint.y);
                    if (dist > 10) {
                        createLineSegment(this.lastPoint, pt, dist);
                        this.lastPoint = pt;
                    }
                }

                if (SETTINGS.architectTool === 'eraser') {
                    this.hoveredEraseBody = findEraseTarget(pt);
                } else {
                    this.hoveredEraseBody = null;
                }
            }
            onMouseUp(e) {
                if (SETTINGS.architectTool === 'line' && this.startPoint) {
                    let endPoint = { x: e.offsetX, y: e.offsetY };
                    if (e.shiftKey) {
                        const dx = Math.abs(endPoint.x - this.startPoint.x);
                        const dy = Math.abs(endPoint.y - this.startPoint.y);
                        if (dx > dy) endPoint.y = this.startPoint.y;
                        else endPoint.x = this.startPoint.x;
                    }
                    createStraightLine(this.startPoint, endPoint);
                }
                this.reset();
            }
            onMouseLeave() { this.reset(); }
        }

        const shatterState = new ShatterState();
        const dragState = new DragState();
        const drawState = new DrawState();
        let activeState = shatterState;

        document.addEventListener('keydown', (e) => {
            if (!audioEngine.initialized) audioEngine.init();
            audioEngine.click();

            // Undo Logic
            if ((e.ctrlKey || e.metaKey) && e.key === 'z') {
                if (undoStack.length > 0) {
                    const lastBody = undoStack.pop();
                    removeArchitectBody(lastBody);
                    const nearby = Matter.Query.region(Composite.allBodies(world), lastBody.bounds);
                    nearby.forEach(b => Sleeping.set(b, false));
                }
                return;
            }

            // Typing Mode Logic
            if (SETTINGS.spawnMode === 'typing') {
                const bufferDisplay = document.getElementById('typing-buffer-display');

                if (SETTINGS.typingType === 'char') {
                    if (e.key.length === 1) triggerSpawn(e.key);
                } else {
                    if (e.key === 'Enter') {
                        enterHoldStart = performance.now();
                    } else if (e.key === 'Backspace') {
                        typingBuffer = typingBuffer.slice(0, -1);
                        bufferDisplay.innerText = typingBuffer + "_";
                    } else if (e.key.length === 1) {
                        typingBuffer += e.key;
                        bufferDisplay.innerText = typingBuffer + "_";
                    }
                }
            }

            activeState?.onKeyDown?.(e);
        });

        document.addEventListener('keyup', (e) => {
            if (SETTINGS.spawnMode === 'typing' && SETTINGS.typingType === 'enter' && e.key === 'Enter') {
                const bufferDisplay = document.getElementById('typing-buffer-display');
                if (typingBuffer.length > 0) {
                    const held = enterHoldStart ? performance.now() - enterHoldStart : 0;
                    const clamped = Math.min(2000, Math.max(0, held));
                    const massScale = 1 + (clamped / 2000) * 2; 
                    const sizeScale = 1 + (clamped / 2000) * 0.2;
                    triggerSpawn(typingBuffer, { massScale, sizeScale });
                    typingBuffer = "";
                    bufferDisplay.innerText = "";
                }
                enterHoldStart = null;
            }
            activeState?.onKeyUp?.(e);
        });

        canvas.addEventListener('mousedown', (e) => activeState?.onMouseDown?.(e));
        canvas.addEventListener('mouseup', (e) => activeState?.onMouseUp?.(e));
        canvas.addEventListener('mouseleave', () => activeState?.onMouseLeave?.());
        canvas.addEventListener('mousemove', (e) => activeState?.onMouseMove?.(e));

        function removeArchitectBody(body) {
            Composite.remove(architectLayer, body);
            const idx = undoStack.indexOf(body);
            if (idx > -1) undoStack.splice(idx, 1);
            if (body.label === 'fan-field') {
                fanFields = fanFields.filter(f => f.body !== body);
            }
        }

        function findEraseTarget(pt) {
            const bodies = Composite.allBodies(architectLayer);
            const eraseRadius = 20;
            for (let b of bodies) {
                if (Matter.Vertices.contains(b.vertices, pt) ||
                    Math.hypot(b.position.x - pt.x, b.position.y - pt.y) < eraseRadius) {
                    return b;
                }
            }
            return null;
        }

        function getLineProps() {
            if (SETTINGS.lineType === 'kill') {
                return { color: CONFIG.colors.kill, isSensor: true, restitution: 0, label: 'kill-line' };
            }
            if (SETTINGS.lineType === 'bounce') {
                return { color: CONFIG.colors.bounce, isSensor: false, restitution: 1.5, label: 'bounce-line' };
            }
            return { color: currentLineColor || CONFIG.colors.line, isSensor: false, restitution: 0, label: 'drawn-line' };
        }

        function createFan(pt) {
            const dir = SETTINGS.fanDirection;
            const body = Bodies.circle(pt.x, pt.y, 12, {
                isStatic: true,
                isSensor: true,
                render: { visible: true, fillStyle: '#224466' },
                label: 'fan-field',
                plugin: { dir: { ...dir }, strength: SETTINGS.fanStrength }
            });
            Composite.add(architectLayer, body);
            undoStack.push(body);
            fanFields.push({
                body,
                radius: SETTINGS.fanRadius,
                dir: { ...dir },
                strength: SETTINGS.fanStrength
            });
        }

        function createLineSegment(p1, p2, dist) {
            const angle = Math.atan2(p2.y - p1.y, p2.x - p1.x);
            const midX = (p1.x + p2.x) / 2;
            const midY = (p1.y + p2.y) / 2;
            const props = getLineProps();
            const body = Bodies.rectangle(midX, midY, dist, SETTINGS.lineThickness, {
                isStatic: true,
                angle: angle,
                friction: SETTINGS.lineFriction,
                restitution: props.restitution || 0,
                isSensor: props.isSensor || false,
                render: { visible: true, fillStyle: props.color },
                label: props.label,
                plugin: { lineType: SETTINGS.lineType }
            });
            Composite.add(architectLayer, body);
            undoStack.push(body); 
        }

        function createStraightLine(p1, p2) {
            const dx = p2.x - p1.x;
            const dy = p2.y - p1.y;
            const dist = Math.hypot(dx, dy);
            if (dist < 5) return; 
            createLineSegment(p1, p2, dist);
        }

        // --- GAME LOGIC ---
        function refillQueue() {
            let allWords = [];
            SETTINGS.textSource.forEach(s => allWords = allWords.concat(s.split(/\s+/)));
            wordQueue = allWords;
        }
        refillQueue();

        let spawnTimer = 0;
        let frameCount = 0;
        
        function triggerSpawn(text, options = {}) {
            const x = (width/2) + (Math.random()-0.5) * (width*0.6);
            const comp = wordFactory.create(text, x, -100, options);
            Composite.rotate(comp, (Math.random()-0.5), {x:x, y:-100});
            Composite.add(world, comp);
            wordComposites.push(comp);
        }

        Events.on(engine, 'collisionStart', (event) => {
            event.pairs.forEach(pair => {
                const killBody = [pair.bodyA, pair.bodyB].find(b => b.label === 'kill-line');
                const letterBody = [pair.bodyA, pair.bodyB].find(b => b.plugin && b.plugin.wordComposite);
                if (killBody && letterBody && letterBody.plugin.wordComposite?.plugin?.intact) {
                    shatter(letterBody.plugin.wordComposite, letterBody.position);
                }
            });
        });

        function update() {
            frameCount++;
            Engine.update(engine, 1000 / 60);
            engine.world.gravity.y = SETTINGS.gravity;

            // Only Auto-Spawn if in Auto Mode
            if (SETTINGS.spawnMode === 'auto') {
                if (spawnTimer <= 0) {
                    if (wordQueue.length === 0 && SETTINGS.loop) refillQueue();
                    if (wordQueue.length > 0) {
                        triggerSpawn(wordQueue.shift());
                        spawnTimer = SETTINGS.spawnInterval;
                    }
                }
                spawnTimer--;
            }
            
            applyFanForces();
            updateAudioTension();
            garbageCollect();
            draw();
            requestAnimationFrame(update);
        }

        function checkShatterAt(point) {
            wordComposites.forEach(comp => {
                if (!comp.plugin.intact) return;
                const bodies = Composite.allBodies(comp);
                if (!bodies.length) return;
                
                let cx = 0, cy = 0;
                bodies.forEach(b => { cx += b.position.x; cy += b.position.y; });
                cx /= bodies.length; cy /= bodies.length;

                if (Math.hypot(point.x - cx, point.y - cy) < CONFIG.disruptRadius) {
                    shatter(comp, point);
                }
            });
        }

        function shatter(comp, source) {
            if (!comp.plugin.intact) return;
            comp.plugin.intact = false;
            Composite.remove(comp, Composite.allConstraints(comp)); 
            audioEngine.triggerBreak((source.x / width) * 2 - 1); 
            
            Composite.allBodies(comp).forEach(b => {
                b.plugin.char = GLYPHS[Math.floor(Math.random() * GLYPHS.length)];
                b.plugin.isBroken = true;
                b.friction = 0.05; 
                b.restitution = 0.1;
                Sleeping.set(b, false);
                const fx = b.position.x - source.x;
                const fy = b.position.y - source.y;
                const len = Math.hypot(fx, fy) || 1;
                const forceMag = SETTINGS.force * b.mass;
                Body.applyForce(b, b.position, { x: (fx/len)*forceMag, y: (fy/len)*forceMag });
                Body.setAngularVelocity(b, (Math.random()-0.5)*0.3);
                
                for(let i=0; i<3; i++) particles.push(new Particle(b.position.x, b.position.y));
            });
            glitchIntensity = 5;
        }

        function applyFanForces() {
            if (fanFields.length === 0) return;
            const bodies = Composite.allBodies(world).filter(b => b.plugin && b.plugin.char);
            fanFields.forEach(fan => {
                bodies.forEach(b => {
                    const dx = b.position.x - fan.body.position.x;
                    const dy = b.position.y - fan.body.position.y;
                    const dist = Math.hypot(dx, dy);
                    if (dist < fan.radius) {
                        const falloff = 1 - (dist / fan.radius);
                        Body.applyForce(b, b.position, { 
                            x: fan.dir.x * fan.strength * falloff * b.mass, 
                            y: fan.dir.y * fan.strength * falloff * b.mass 
                        });
                    }
                });
            });
        }

        function updateAudioTension() {
            const textBodies = Composite.allBodies(world).filter(b => b.plugin && b.plugin.char);
            if (textBodies.length === 0) {
                audioEngine.setTension(0);
                return;
            }
            const highest = Math.min(...textBodies.map(b => b.position.y));
            const tension = Math.max(0, 1 - (highest / (height * 0.8)));
            audioEngine.setTension(Math.min(1, tension));
        }

        function garbageCollect() {
            if (frameCount % 60 !== 0) return; 

            const all = Composite.allBodies(world);
            const toRemove = [];
            for (let i = 0; i < all.length; i++) {
                if (all[i].position.y > height + 200) toRemove.push(all[i]);
            }
            Composite.remove(world, toRemove);
            const textBodies = all.filter(b => b.plugin && b.plugin.char);
            if (textBodies.length > CONFIG.maxBodies) {
                const excess = textBodies.slice(0, textBodies.length - CONFIG.maxBodies);
                Composite.remove(world, excess);
            }
        }

        // --- RENDERER ---
        function draw() {
            ctx.clearRect(0,0,width,height);
            if(glitchIntensity > 0.1) {
                ctx.fillStyle = getComputedStyle(document.body).getPropertyValue('--bg');
                ctx.fillRect(0,0,width,height);
            }

            let ox = 0, oy = 0;
            if(glitchIntensity > 0.1) {
                ox = (Math.random()-0.5)*glitchIntensity;
                oy = (Math.random()-0.5)*glitchIntensity;
                glitchIntensity *= 0.9;
            }
            
            ctx.save();
            ctx.translate(ox, oy);

            const bodies = Composite.allBodies(world);
            const architectBodies = Composite.allBodies(architectLayer);
            
            // Draw Architect Lines
            architectBodies.forEach(b => {
                if (b.label === 'fan-field') {
                    const fan = fanFields.find(f => f.body === b);
                    const dir = b.plugin?.dir || { x: 0, y: -1 };
                    ctx.save();
                    ctx.translate(b.position.x, b.position.y);
                    ctx.strokeStyle = '#77aaff';
                    ctx.lineWidth = 1;
                    ctx.globalAlpha = 0.2;
                    if (fan) {
                        ctx.beginPath();
                        ctx.arc(0, 0, fan.radius, 0, Math.PI*2);
                        ctx.stroke();
                    }
                    ctx.globalAlpha = 1;
                    ctx.beginPath();
                    ctx.arc(0, 0, 12, 0, Math.PI*2);
                    ctx.fillStyle = '#0f1f3a';
                    ctx.fill();
                    ctx.stroke();
                    ctx.rotate(Math.atan2(dir.y, dir.x));
                    ctx.fillStyle = '#77aaff';
                    ctx.beginPath();
                    ctx.moveTo(-6, 4);
                    ctx.lineTo(6, 0);
                    ctx.lineTo(-6, -4);
                    ctx.closePath();
                    ctx.fill();
                    ctx.restore();
                    return;
                }

                if (b.label === 'drawn-line' || b.label === 'kill-line' || b.label === 'bounce-line') {
                    ctx.beginPath();
                    ctx.moveTo(b.vertices[0].x, b.vertices[0].y);
                    for(let j=1; j<b.vertices.length; j++) {
                        ctx.lineTo(b.vertices[j].x, b.vertices[j].y);
                    }
                    ctx.lineTo(b.vertices[0].x, b.vertices[0].y);
                    
                    ctx.fillStyle = b.render.fillStyle || '#ffffff';
                    ctx.globalAlpha = b.label === 'kill-line' ? 0.7 : 1;
                    ctx.fill();

                    ctx.beginPath();
                    ctx.strokeStyle = drawState.hoveredEraseBody === b ? '#ff5555' : (b.render.fillStyle || '#ffffff');
                    ctx.globalAlpha = 0.6;
                    ctx.lineWidth = drawState.hoveredEraseBody === b ? 2 : 1;
                    ctx.moveTo(b.vertices[0].x, b.vertices[0].y);
                    for(let j=1; j<b.vertices.length; j++) ctx.lineTo(b.vertices[j].x, b.vertices[j].y);
                    ctx.stroke();
                    ctx.globalAlpha = 1.0;
                }
            });

            // Draw Words
            bodies.forEach(b => {
                if (b.plugin && b.plugin.char) {
                    ctx.save();
                    ctx.translate(b.position.x, b.position.y);
                    ctx.rotate(b.angle);
                    ctx.textAlign="center"; ctx.textBaseline="middle";
                    ctx.font = `${b.plugin.size || CONFIG.fontSize}px 'Courier New'`;
                    
                    const isHebrew = /[\u0590-\u05FF]/.test(b.plugin.char);
                    if (isHebrew && !b.plugin.isBroken) {
                        ctx.shadowColor = CONFIG.colors.hebrew;
                        ctx.shadowBlur = 10; 
                    }

                    if (b.plugin.isBroken) {
                        ctx.fillStyle = CONFIG.colors.shard;
                        if(Math.random()>0.98) ctx.fillStyle='#fff'; 
                    } else {
                        ctx.fillStyle = b.isSleeping ? '#888' : b.plugin.color;
                    }
                    ctx.fillText(b.plugin.char, 0, 0);
                    ctx.shadowBlur = 0;
                    ctx.restore();
                }
            });
            
            // Draw Particles
            for(let i=particles.length-1; i>=0; i--) {
                let p = particles[i];
                if(!p.update()) particles.splice(i,1);
                else p.draw(ctx, CONFIG.colors.dust);
            }
            ctx.globalAlpha = 1;

            // Draw Tool Overlays
            if (SETTINGS.interactionMode === 'draw' && drawState.currentPoint) {
                if (SETTINGS.architectTool === 'line' && drawState.isDrawing && drawState.startPoint) {
                    ctx.beginPath();
                    ctx.moveTo(drawState.startPoint.x, drawState.startPoint.y);
                    ctx.lineTo(drawState.currentPoint.x, drawState.currentPoint.y);
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 1;
                    ctx.setLineDash([5, 5]);
                    ctx.stroke();
                    ctx.setLineDash([]);
                } else if (SETTINGS.architectTool === 'eraser') {
                    ctx.beginPath();
                    ctx.arc(drawState.currentPoint.x, drawState.currentPoint.y, 20, 0, Math.PI*2);
                    ctx.strokeStyle = drawState.hoveredEraseBody ? '#ff5555' : '#777';
                    ctx.lineWidth = drawState.hoveredEraseBody ? 2 : 1;
                    ctx.stroke();
                }
            }

            ctx.restore();
        }

        // --- CONTROLS ---
        const panel = document.getElementById('control-panel');
        const trigger = document.getElementById('settings-trigger');
        trigger.addEventListener('click', () => panel.classList.toggle('active'));
        document.addEventListener('click', () => { if(!audioEngine.initialized) audioEngine.init(); });

        const bindSlider = (id, settingKey, displayId) => {
            const el = document.getElementById(id);
            const disp = document.getElementById(displayId);
            el.addEventListener('input', (e) => {
                const val = parseFloat(e.target.value);
                SETTINGS[settingKey] = val;
                disp.innerText = val;
            });
        };
        bindSlider('inp-gravity', 'gravity', 'val-gravity');
        bindSlider('inp-force', 'force', 'val-force');
        bindSlider('inp-speed', 'spawnInterval', 'val-speed');
        
        bindSlider('inp-friction', 'lineFriction', 'val-friction');
        bindSlider('inp-thickness', 'lineThickness', 'val-thickness');

        const btnLineStandard = document.getElementById('btn-line-standard');
        const btnLineKill = document.getElementById('btn-line-kill');
        const btnLineBounce = document.getElementById('btn-line-bounce');

        const setLineType = (type) => {
            SETTINGS.lineType = type;
            btnLineStandard.classList.toggle('active', type === 'standard');
            btnLineKill.classList.toggle('active', type === 'kill');
            btnLineBounce.classList.toggle('active', type === 'bounce');
        };

        btnLineStandard.addEventListener('click', () => setLineType('standard'));
        btnLineKill.addEventListener('click', () => setLineType('kill'));
        btnLineBounce.addEventListener('click', () => setLineType('bounce'));

        const btnFanLeft = document.getElementById('btn-fan-left');
        const btnFanUp = document.getElementById('btn-fan-up');
        const btnFanRight = document.getElementById('btn-fan-right');
        const btnFanDown = document.getElementById('btn-fan-down');

        const setFanDirection = (dir) => {
            SETTINGS.fanDirection = dir;
            btnFanLeft.classList.toggle('active', dir.x === -1 && dir.y === 0);
            btnFanUp.classList.toggle('active', dir.x === 0 && dir.y === -1);
            btnFanRight.classList.toggle('active', dir.x === 1 && dir.y === 0);
            btnFanDown.classList.toggle('active', dir.x === 0 && dir.y === 1);
        };

        btnFanLeft.addEventListener('click', () => setFanDirection({ x: -1, y: 0 }));
        btnFanUp.addEventListener('click', () => setFanDirection({ x: 0, y: -1 }));
        btnFanRight.addEventListener('click', () => setFanDirection({ x: 1, y: 0 }));
        btnFanDown.addEventListener('click', () => setFanDirection({ x: 0, y: 1 }));

        const fanStrengthSlider = document.getElementById('inp-fan-strength');
        const fanStrengthVal = document.getElementById('val-fan-strength');
        fanStrengthSlider.addEventListener('input', (e) => {
            const val = parseFloat(e.target.value);
            SETTINGS.fanStrength = val;
            fanStrengthVal.innerText = val.toFixed(4);
            fanFields.forEach(f => f.strength = val);
        });

        document.getElementById('inp-vol').addEventListener('input', (e) => {
            const val = parseFloat(e.target.value);
            document.getElementById('val-vol').innerText = val;
            audioEngine.setVolume(val);
        });
        document.getElementById('btn-audio-toggle').addEventListener('click', (e) => {
            e.stopPropagation(); 
            audioEngine.toggle();
        });

        // Mode Toggles
        const btnDrag = document.getElementById('btn-mode-drag');
        const btnShatter = document.getElementById('btn-mode-shatter');
        const btnDraw = document.getElementById('btn-mode-draw');
        
        const setMode = (mode) => {
            activeState?.exit?.();
            SETTINGS.interactionMode = mode;
            activeState = mode === 'drag' ? dragState : (mode === 'draw' ? drawState : shatterState);
            activeState?.enter?.();
            btnDrag.classList.toggle('active', mode === 'drag');
            btnShatter.classList.toggle('active', mode === 'shatter');
            btnDraw.classList.toggle('active', mode === 'draw');
            
            document.body.classList.remove('mode-drag', 'mode-shatter', 'mode-draw');
            document.body.classList.add(`mode-${mode}`);
            if (mode !== 'draw') drawState.reset();
        };

        btnDrag.addEventListener('click', () => setMode('drag'));
        btnShatter.addEventListener('click', () => setMode('shatter'));
        btnDraw.addEventListener('click', () => setMode('draw'));

        // Architect Sub-Tools
        const btnToolFree = document.getElementById('btn-tool-free');
        const btnToolLine = document.getElementById('btn-tool-line');
        const btnToolFan = document.getElementById('btn-tool-fan');
        const btnToolErase = document.getElementById('btn-tool-erase');

        const setArchitectTool = (tool) => {
            SETTINGS.architectTool = tool;
            btnToolFree.classList.toggle('active', tool === 'freehand');
            btnToolLine.classList.toggle('active', tool === 'line');
            btnToolFan.classList.toggle('active', tool === 'fan');
            btnToolErase.classList.toggle('active', tool === 'eraser');
            
            document.body.classList.remove('tool-free', 'tool-line', 'tool-fan', 'tool-erase');
            document.body.classList.add(`tool-${tool}`);
        };

        btnToolFree.addEventListener('click', () => setArchitectTool('freehand'));
        btnToolLine.addEventListener('click', () => setArchitectTool('line'));
        btnToolFan.addEventListener('click', () => setArchitectTool('fan'));
        btnToolErase.addEventListener('click', () => setArchitectTool('eraser'));
        document.body.classList.add('tool-free');
        setMode('shatter');

        // Trigger Mode Toggles
        const btnTrigClick = document.getElementById('btn-trigger-click');
        const btnTrigHover = document.getElementById('btn-trigger-hover');

        btnTrigClick.addEventListener('click', () => {
            SETTINGS.triggerMode = 'click';
            btnTrigClick.classList.add('active');
            btnTrigHover.classList.remove('active');
        });
        btnTrigHover.addEventListener('click', () => {
            SETTINGS.triggerMode = 'hover';
            btnTrigHover.classList.add('active');
            btnTrigClick.classList.remove('active');
        });

        // --- NEW SPAWN MODE TOGGLES ---
        const btnSpawnAuto = document.getElementById('btn-spawn-auto');
        const btnSpawnType = document.getElementById('btn-spawn-type');
        const typingSettingsDiv = document.getElementById('typing-settings');
        
        btnSpawnAuto.addEventListener('click', () => {
            SETTINGS.spawnMode = 'auto';
            btnSpawnAuto.classList.add('active');
            btnSpawnType.classList.remove('active');
            typingSettingsDiv.style.display = 'none';
        });

        btnSpawnType.addEventListener('click', () => {
            SETTINGS.spawnMode = 'typing';
            btnSpawnType.classList.add('active');
            btnSpawnAuto.classList.remove('active');
            typingSettingsDiv.style.display = 'flex';
            typingBuffer = "";
            document.getElementById('typing-buffer-display').innerText = "";
        });

        const btnTypeChar = document.getElementById('btn-type-char');
        const btnTypeEnter = document.getElementById('btn-type-enter');
        const typeDesc = document.getElementById('type-desc');

        btnTypeChar.addEventListener('click', () => {
            SETTINGS.typingType = 'char';
            btnTypeChar.classList.add('active');
            btnTypeEnter.classList.remove('active');
            typeDesc.innerText = "Press any key to drop a character.";
            typingBuffer = "";
            document.getElementById('typing-buffer-display').innerText = "";
        });

        btnTypeEnter.addEventListener('click', () => {
            SETTINGS.typingType = 'enter';
            btnTypeEnter.classList.add('active');
            btnTypeChar.classList.remove('active');
            typeDesc.innerText = "Type a word, then press ENTER to drop.";
        });

        document.getElementById('btn-update-text').addEventListener('click', () => {
            const raw = document.getElementById('inp-text').value;
            if (raw.trim().length > 0) {
                SETTINGS.textSource = [raw];
                refillQueue();
            }
        });

        document.getElementById('btn-clear').addEventListener('click', () => {
            Composite.clear(world, false, true); 
            Composite.clear(architectLayer, false, true);
            Composite.add(world, architectLayer);
            Composite.add(world, mouseConstraint);
            resize(); 
            wordComposites = [];
            refillQueue();
            undoStack = [];
            particles = [];
            fanFields = [];
        });
        document.getElementById('inp-loop').addEventListener('change', (e) => SETTINGS.loop = e.target.checked);

        // --- NEW FEATURES IMPLEMENTATION ---

        // 1. SWEEP DEBRIS
        document.getElementById('btn-sweep').addEventListener('click', () => {
            const all = Composite.allBodies(world);
            const debris = all.filter(b => b.plugin && b.plugin.isBroken);
            Composite.remove(world, debris);
            particles = []; 
        });

        // 2. SAVE LAYOUT
        document.getElementById('btn-save').addEventListener('click', () => {
            const lines = Composite.allBodies(architectLayer).map(b => {
                if (b.label === 'fan-field') {
                    const fan = fanFields.find(f => f.body === b);
                    return {
                        kind: 'fan',
                        x: b.position.x,
                        y: b.position.y,
                        dir: fan?.dir || b.plugin?.dir || { x: 0, y: -1 },
                        strength: fan?.strength || SETTINGS.fanStrength,
                        radius: fan?.radius || SETTINGS.fanRadius
                    };
                }
                const len = Math.hypot(b.vertices[1].x - b.vertices[0].x, b.vertices[1].y - b.vertices[0].y);
                const thickness = Math.hypot(b.vertices[0].x - b.vertices[3].x, b.vertices[0].y - b.vertices[3].y);
                return { 
                    kind: 'line',
                    x: b.position.x, 
                    y: b.position.y, 
                    angle: b.angle, 
                    length: len,
                    thickness: thickness,
                    color: b.render.fillStyle || '#ffffff',
                    lineType: b.plugin?.lineType || 'standard'
                };
            });

            localStorage.setItem('babel_architect_v1', JSON.stringify(lines));
            
            const btn = document.getElementById('btn-save');
            const original = btn.innerText;
            btn.innerText = "SAVED!";
            setTimeout(() => btn.innerText = original, 1000);
        });

        // 3. LOAD LAYOUT
        document.getElementById('btn-load').addEventListener('click', () => {
            const raw = localStorage.getItem('babel_architect_v1');
            if (!raw) return;
            
            Composite.clear(architectLayer, false, true);
            undoStack = [];
            fanFields = [];

            const data = JSON.parse(raw);
            data.forEach(item => {
                if (item.kind === 'fan') {
                    const body = Bodies.circle(item.x, item.y, 12, {
                        isStatic: true,
                        isSensor: true,
                        render: { visible: true, fillStyle: '#224466' },
                        label: 'fan-field',
                        plugin: { dir: { ...(item.dir || { x: 0, y: -1 }) }, strength: item.strength || SETTINGS.fanStrength }
                    });
                    Composite.add(architectLayer, body);
                    undoStack.push(body);
                    fanFields.push({
                        body,
                        radius: item.radius || SETTINGS.fanRadius,
                        dir: { ...(item.dir || { x: 0, y: -1 }) },
                        strength: item.strength || SETTINGS.fanStrength
                    });
                    return;
                }

                const lineType = item.lineType || 'standard';
                const color = item.color || (lineType === 'kill' ? CONFIG.colors.kill : (lineType === 'bounce' ? CONFIG.colors.bounce : currentLineColor));
                const body = Bodies.rectangle(item.x, item.y, item.length, item.thickness || SETTINGS.lineThickness, {
                    isStatic: true,
                    angle: item.angle,
                    friction: SETTINGS.lineFriction,
                    restitution: lineType === 'bounce' ? 1.5 : 0,
                    isSensor: lineType === 'kill',
                    render: { visible: true, fillStyle: color },
                    label: lineType === 'kill' ? 'kill-line' : (lineType === 'bounce' ? 'bounce-line' : 'drawn-line'),
                    plugin: { lineType }
                });
                Composite.add(architectLayer, body);
                undoStack.push(body);
            });
        });

        // 4. VISUAL SETTINGS LISTENERS
        const inpFontSize = document.getElementById('inp-fontsize');
        inpFontSize.addEventListener('change', (e) => {
            CONFIG.fontSize = parseInt(e.target.value);
            CONFIG.letterSpacing = CONFIG.fontSize * 0.7; 
            document.getElementById('val-fontsize').innerText = CONFIG.fontSize;
            Composite.clear(world, false, true);
            wordComposites = [];
            refillQueue();
        });
        inpFontSize.addEventListener('input', (e) => {
             document.getElementById('val-fontsize').innerText = e.target.value;
        });

        const colorBtns = document.querySelectorAll('#line-color-picker button');
        colorBtns.forEach(btn => {
            btn.addEventListener('click', () => {
                colorBtns.forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                currentLineColor = btn.getAttribute('data-col');
                CONFIG.colors.line = currentLineColor;
            });
        });

        document.getElementById('btn-load-bg').addEventListener('click', () => {
            const url = document.getElementById('inp-bg-url').value;
            if(url) document.getElementById('bg-reference').style.backgroundImage = `url('${url}')`;
        });
        document.getElementById('btn-clear-bg').addEventListener('click', () => {
            document.getElementById('bg-reference').style.backgroundImage = '';
            document.getElementById('inp-bg-url').value = '';
        });

        setLineType(SETTINGS.lineType);
        setFanDirection(SETTINGS.fanDirection);
        fanStrengthVal.innerText = SETTINGS.fanStrength.toFixed(4);
        fanStrengthSlider.value = SETTINGS.fanStrength;

        update();

    </script>
</body>
</html>
